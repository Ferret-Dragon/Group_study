<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Graphs - DSA Study Platform</title>
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <!-- Navigation Bar -->
    <nav class="navbar">
        <div class="nav-container">
            <a href="home.html" class="nav-brand">DSA Study Platform</a>
            <div class="menu-toggle" onclick="toggleMenu()">
                <span></span>
                <span></span>
                <span></span>
            </div>
            <ul class="nav-menu" id="navMenu">
                <li class="nav-item"><a href="home.html" class="nav-link">Home</a></li>
                <li class="nav-item"><a href="graphs.html" class="nav-link active">Graphs</a></li>
                <li class="nav-item"><a href="divide-conquer.html" class="nav-link">Divide & Conquer</a></li>
                <li class="nav-item"><a href="greedy.html" class="nav-link">Greedy</a></li>
                <li class="nav-item"><a href="dynamic-programming.html" class="nav-link">Dynamic Programming</a></li>
                <li class="nav-item"><a href="max-flow.html" class="nav-link">Max Flow</a></li>
                <li class="nav-item"><a href="formulas.html" class="nav-link">Formulas</a></li>
                <li class="nav-item"><a href="practice-exam.html" class="nav-link">Practice Exam</a></li>
                <li class="nav-item"><a href="practice-quiz5.html" class="nav-link">Quiz 5 Practice</a></li>
                <li class="nav-item"><a href="review.html" class="nav-link">Final Review</a></li>
            </ul>
        </div>
    </nav>

    <!-- Header -->
    <header>
        <h1>Graphs</h1>
        <p class="subtitle">BFS, DFS, Topological Sort, Strongly Connected Components, Dijkstra's Algorithm</p>
    </header>

    <div class="container">
        <div class="container">
<div class="subtopic">
                            <h3>Graph Representations</h3>
                            <div class="key-concepts">
                                <h4>Key Concepts:</h4>
                                <ul>
                                    <li><strong>Adjacency Matrix:</strong> 2D array, O(1) edge lookup, O(V¬≤) space</li>
                                    <li><strong>Adjacency List:</strong> Array of lists, O(V+E) space, better for sparse graphs</li>
                                    <li><strong>When to use which:</strong> Matrix for dense graphs, lists for sparse</li>
                                </ul>
                            </div>
                            <div class="practice-tip">
                                <h4>Practice Tip:</h4>
                                <p>Draw a simple graph and convert it between both representations. This is a common exam question!</p>
                            </div>
                        </div>

                        <div class="subtopic">
                            <h3>Breadth-First Search (BFS)</h3>
                            <div class="key-concepts">
                                <h4>Key Concepts:</h4>
                                <ul>
                                    <li><strong>Uses Queue (FIFO)</strong> - explores level by level</li>
                                    <li><strong>Time Complexity:</strong> O(V + E) with adjacency list</li>
                                    <li><strong>Space Complexity:</strong> O(V) for queue and visited array</li>
                                    <li><strong>Applications:</strong> Shortest path in unweighted graphs, level-order traversal</li>
                                    <li><strong>Output:</strong> BFS tree, distances from source</li>
                                </ul>
                            </div>
                            <div class="video-recommendations">
                                <h4>Video Recommendations:</h4>
                                <a href="https://www.youtube.com/watch?v=oDqjPvD54Ss" target="_blank" class="video-link">üé• Abdul Bari - BFS Graph Traversal (17 min)</a>
                                <a href="https://www.youtube.com/watch?v=hettiSrJjM4" target="_blank" class="video-link">üé• William Fiset - BFS Shortest Path (13 min)</a>
                            </div>
                            <div class="practice-tip">
                                <h4>Walkthrough:</h4>
                                <ol>
                                    <li>Initialize: Mark source as visited, enqueue source</li>
                                    <li>While queue not empty: dequeue vertex u</li>
                                    <li>For each neighbor v of u: if not visited, mark visited, enqueue v, set distance[v] = distance[u] + 1</li>
                                    <li>Result: All reachable vertices visited, shortest paths computed</li>
                                </ol>
                            </div>

                            <div class="visual-section">
                                <h4>üìä Visual Example: BFS Traversal</h4>
                                <div class="graph-container">
                                    <svg width="600" height="300" viewBox="0 0 600 300">
                                        <!-- Graph edges -->
                                        <line x1="100" y1="50" x2="200" y2="100" stroke="#90caf9" stroke-width="2"/>
                                        <line x1="100" y1="50" x2="200" y2="150" stroke="#90caf9" stroke-width="2"/>
                                        <line x1="200" y1="100" x2="350" y2="75" stroke="#90caf9" stroke-width="2"/>
                                        <line x1="200" y1="100" x2="350" y2="125" stroke="#90caf9" stroke-width="2"/>
                                        <line x1="200" y1="150" x2="350" y2="175" stroke="#90caf9" stroke-width="2"/>
                                        <line x1="200" y1="150" x2="350" y2="225" stroke="#90caf9" stroke-width="2"/>
                                        <line x1="350" y1="125" x2="500" y2="150" stroke="#90caf9" stroke-width="2"/>

                                        <!-- Nodes -->
                                        <circle cx="100" cy="50" r="25" fill="#42a5f5" stroke="#0d47a1" stroke-width="2"/>
                                        <text x="100" y="55" text-anchor="middle" fill="white" font-weight="bold">A</text>
                                        <text x="100" y="95" text-anchor="middle" fill="#0d47a1" font-size="12">Level 0</text>

                                        <circle cx="200" cy="100" r="25" fill="#64b5f6" stroke="#0d47a1" stroke-width="2"/>
                                        <text x="200" y="105" text-anchor="middle" fill="white" font-weight="bold">B</text>
                                        <text x="200" y="140" text-anchor="middle" fill="#0d47a1" font-size="12">Level 1</text>

                                        <circle cx="200" cy="150" r="25" fill="#64b5f6" stroke="#0d47a1" stroke-width="2"/>
                                        <text x="200" y="155" text-anchor="middle" fill="white" font-weight="bold">C</text>
                                        <text x="200" y="190" text-anchor="middle" fill="#0d47a1" font-size="12">Level 1</text>

                                        <circle cx="350" cy="75" r="25" fill="#90caf9" stroke="#0d47a1" stroke-width="2"/>
                                        <text x="350" y="80" text-anchor="middle" fill="white" font-weight="bold">D</text>

                                        <circle cx="350" cy="125" r="25" fill="#90caf9" stroke="#0d47a1" stroke-width="2"/>
                                        <text x="350" y="130" text-anchor="middle" fill="white" font-weight="bold">E</text>

                                        <circle cx="350" cy="175" r="25" fill="#90caf9" stroke="#0d47a1" stroke-width="2"/>
                                        <text x="350" y="180" text-anchor="middle" fill="white" font-weight="bold">F</text>

                                        <circle cx="350" cy="225" r="25" fill="#90caf9" stroke="#0d47a1" stroke-width="2"/>
                                        <text x="350" y="230" text-anchor="middle" fill="white" font-weight="bold">G</text>

                                        <circle cx="500" cy="150" r="25" fill="#bbdefb" stroke="#0d47a1" stroke-width="2"/>
                                        <text x="500" y="155" text-anchor="middle" fill="white" font-weight="bold">H</text>

                                        <text x="380" y="25" text-anchor="start" fill="#0d47a1" font-size="12">Level 2: D, E, F, G</text>
                                        <text x="520" y="150" text-anchor="start" fill="#0d47a1" font-size="12">Level 3: H</text>
                                    </svg>
                                </div>
                                <div class="graph-legend">
                                    <div class="legend-item">
                                        <div class="legend-color" style="background: #42a5f5;"></div>
                                        <span>Starting node (Level 0)</span>
                                    </div>
                                    <div class="legend-item">
                                        <div class="legend-color" style="background: #64b5f6;"></div>
                                        <span>Level 1</span>
                                    </div>
                                    <div class="legend-item">
                                        <div class="legend-color" style="background: #90caf9;"></div>
                                        <span>Level 2</span>
                                    </div>
                                    <div class="legend-item">
                                        <div class="legend-color" style="background: #bbdefb;"></div>
                                        <span>Level 3</span>
                                    </div>
                                </div>
                                <p><strong>BFS Order from A:</strong> A ‚Üí B ‚Üí C ‚Üí D ‚Üí E ‚Üí F ‚Üí G ‚Üí H</p>
                                <p><strong>Queue progression:</strong> [A] ‚Üí [B,C] ‚Üí [C,D,E] ‚Üí [D,E,F,G] ‚Üí [E,F,G] ‚Üí [F,G,H] ‚Üí [G,H] ‚Üí [H] ‚Üí []</p>
                            </div>

                            <div class="trace-exercise">
                                <h4>‚úèÔ∏è Trace Exercise: Practice BFS</h4>
                                <p><strong>Try this yourself:</strong> Given the graph above, what would be the BFS traversal starting from node C?</p>
                                <button class="show-answer-btn" onclick="toggleAnswer('bfs-trace-1')">Show Answer</button>
                                <div class="hidden-answer" id="bfs-trace-1">
                                    <p><strong>Answer:</strong> C ‚Üí B ‚Üí A ‚Üí F ‚Üí G ‚Üí D ‚Üí E ‚Üí H</p>
                                    <p><strong>Explanation:</strong></p>
                                    <ul>
                                        <li>Level 0: C (start)</li>
                                        <li>Level 1: B, F, G (neighbors of C)</li>
                                        <li>Level 2: A (neighbor of B), D, E (neighbors of B and F)</li>
                                        <li>Level 3: H (neighbor of E)</li>
                                    </ul>
                                    <p><strong>Queue:</strong> [C] ‚Üí [B,F,G] ‚Üí [F,G,A] ‚Üí [G,A,D,E] ‚Üí [A,D,E] ‚Üí [D,E] ‚Üí [E,H] ‚Üí [H] ‚Üí []</p>
                                </div>
                            </div>

                            <div class="quiz-box">
                                <h4>üß† Quick Quiz: Test Your BFS Understanding</h4>
                                <div class="quiz-question">
                                    <p><strong>Q1:</strong> What data structure does BFS use?</p>
                                    <div class="quiz-options">
                                        <div class="quiz-option" onclick="checkAnswer(this, false, 'bfs-q1')">A) Stack</div>
                                        <div class="quiz-option" onclick="checkAnswer(this, true, 'bfs-q1')">B) Queue</div>
                                        <div class="quiz-option" onclick="checkAnswer(this, false, 'bfs-q1')">C) Priority Queue</div>
                                        <div class="quiz-option" onclick="checkAnswer(this, false, 'bfs-q1')">D) Hash Table</div>
                                    </div>
                                    <div class="quiz-explanation" id="bfs-q1">
                                        <strong>Correct!</strong> BFS uses a Queue (FIFO - First In First Out) to process vertices level by level. This is the key difference from DFS which uses a stack or recursion.
                                    </div>
                                </div>
                                <div class="quiz-question">
                                    <p><strong>Q2:</strong> In an unweighted graph, BFS finds:</p>
                                    <div class="quiz-options">
                                        <div class="quiz-option" onclick="checkAnswer(this, false, 'bfs-q2')">A) The longest path</div>
                                        <div class="quiz-option" onclick="checkAnswer(this, true, 'bfs-q2')">B) The shortest path</div>
                                        <div class="quiz-option" onclick="checkAnswer(this, false, 'bfs-q2')">C) All possible paths</div>
                                        <div class="quiz-option" onclick="checkAnswer(this, false, 'bfs-q2')">D) The minimum spanning tree</div>
                                    </div>
                                    <div class="quiz-explanation" id="bfs-q2">
                                        <strong>Correct!</strong> BFS guarantees the shortest path in unweighted graphs because it explores nodes level by level, reaching closer nodes first.
                                    </div>
                                </div>
                                <div class="quiz-question">
                                    <p><strong>Q3:</strong> What is the space complexity of BFS?</p>
                                    <div class="quiz-options">
                                        <div class="quiz-option" onclick="checkAnswer(this, false, 'bfs-q3')">A) O(1)</div>
                                        <div class="quiz-option" onclick="checkAnswer(this, false, 'bfs-q3')">B) O(E)</div>
                                        <div class="quiz-option" onclick="checkAnswer(this, true, 'bfs-q3')">C) O(V)</div>
                                        <div class="quiz-option" onclick="checkAnswer(this, false, 'bfs-q3')">D) O(V¬≤)</div>
                                    </div>
                                    <div class="quiz-explanation" id="bfs-q3">
                                        <strong>Correct!</strong> Space complexity is O(V) for the queue and visited array. In the worst case, all vertices might be in the queue at once.
                                    </div>
                                </div>
                            </div>

                            <div class="self-check">
                                <h4>üéØ Self-Check: Can You Explain?</h4>
                                <p>Try explaining these in your own words (cover the answer first!):</p>
                                <ol>
                                    <li><strong>Why does BFS use a queue instead of a stack?</strong>
                                        <button class="show-answer-btn" onclick="toggleAnswer('self-check-1')">Show Answer</button>
                                        <div class="hidden-answer" id="self-check-1">
                                            A queue ensures FIFO (First-In-First-Out) ordering, which means we process vertices in the order we discover them. This guarantees we explore all vertices at distance d before exploring vertices at distance d+1, which is why BFS finds shortest paths.
                                        </div>
                                    </li>
                                    <li><strong>When would you choose BFS over DFS?</strong>
                                        <button class="show-answer-btn" onclick="toggleAnswer('self-check-2')">Show Answer</button>
                                        <div class="hidden-answer" id="self-check-2">
                                            Choose BFS when: (1) You need shortest paths in unweighted graphs, (2) You want to explore nearby nodes first, (3) The solution is likely near the start node. Choose DFS when: (1) You want to explore all paths, (2) Need topological sorting, (3) Detecting cycles, (4) Memory is limited (DFS uses less space in most cases).
                                        </div>
                                    </li>
                                </ol>
                            </div>
                        </div>

                        <div class="subtopic">
                            <h3>Depth-First Search (DFS)</h3>
                            <div class="key-concepts">
                                <h4>Key Concepts:</h4>
                                <ul>
                                    <li><strong>Uses Stack (LIFO)</strong> or recursion - explores as deep as possible first</li>
                                    <li><strong>Time Complexity:</strong> O(V + E)</li>
                                    <li><strong>Space Complexity:</strong> O(V) for recursion stack</li>
                                    <li><strong>Timestamps:</strong> Discovery time d[v] and finish time f[v]</li>
                                    <li><strong>Applications:</strong> Cycle detection, topological sort, SCC, path finding</li>
                                    <li><strong>Edge Classification:</strong> Tree, Back, Forward, Cross edges</li>
                                </ul>
                            </div>
                            <div class="video-recommendations">
                                <h4>Video Recommendations:</h4>
                                <a href="https://www.youtube.com/watch?v=7fujbpJ0LB4" target="_blank" class="video-link">üé• Abdul Bari - DFS Graph Traversal (17 min)</a>
                                <a href="https://www.youtube.com/watch?v=PMMc4VsIacU" target="_blank" class="video-link">üé• MIT OpenCourseWare - DFS and Topological Sort (50 min - if time)</a>
                            </div>
                            <div class="warning-box">
                                <h4>Common Pitfall:</h4>
                                <p>Remember: DFS on an undirected graph only has tree and back edges. Forward and cross edges only appear in directed graphs!</p>
                            </div>
                        </div>

                        <div class="subtopic">
                            <h3>Topological Sort</h3>
                            <div class="key-concepts">
                                <h4>Key Concepts:</h4>
                                <ul>
                                    <li><strong>Only for DAGs</strong> (Directed Acyclic Graphs)</li>
                                    <li><strong>Linear ordering:</strong> If edge u‚Üív exists, u appears before v</li>
                                    <li><strong>Algorithm:</strong> DFS-based - add vertices in reverse finish time order</li>
                                    <li><strong>Time Complexity:</strong> O(V + E)</li>
                                    <li><strong>Cycle Detection:</strong> If back edge found, graph has cycle (no topological sort possible)</li>
                                </ul>
                            </div>
                            <div class="video-recommendations">
                                <h4>Video Recommendations:</h4>
                                <a href="https://www.youtube.com/watch?v=cIBFEhD77b4" target="_blank" class="video-link">üé• William Fiset - Topological Sort (15 min)</a>
                            </div>
                            <div class="practice-tip">
                                <h4>Quick Algorithm:</h4>
                                <ol>
                                    <li>Run DFS on entire graph</li>
                                    <li>When vertex finishes (all descendants explored), push to stack</li>
                                    <li>Pop stack to get topological order</li>
                                </ol>
                            </div>
                        </div>

                        <div class="subtopic">
                            <h3>Strongly Connected Components (SCC)</h3>
                            <div class="key-concepts">
                                <h4>Key Concepts:</h4>
                                <ul>
                                    <li><strong>SCC:</strong> Maximal set of vertices where every vertex is reachable from every other</li>
                                    <li><strong>Kosaraju's Algorithm:</strong> Most common approach</li>
                                    <li><strong>Time Complexity:</strong> O(V + E) - two DFS passes</li>
                                    <li><strong>Steps:</strong> (1) DFS on G to compute finish times, (2) DFS on G^T (transpose) in decreasing finish time order</li>
                                </ul>
                            </div>
                            <div class="video-recommendations">
                                <h4>Video Recommendations:</h4>
                                <a href="https://www.youtube.com/watch?v=RpgcYiky7uw" target="_blank" class="video-link">üé• Tushar Roy - Strongly Connected Components (16 min)</a>
                            </div>
                            <div class="practice-tip">
                                <h4>Walkthrough:</h4>
                                <ol>
                                    <li>Run DFS on original graph G, record finish times</li>
                                    <li>Compute transpose G^T (reverse all edges)</li>
                                    <li>Run DFS on G^T in decreasing finish time order</li>
                                    <li>Each DFS tree in step 3 is one SCC</li>
                                </ol>
                            </div>
                        </div>

                        <div class="subtopic">
                            <h3>Dijkstra's Algorithm (Single-Source Shortest Path)</h3>
                            <div class="key-concepts">
                                <h4>Key Concepts:</h4>
                                <ul>
                                    <li><strong>Requirement:</strong> Non-negative edge weights only!</li>
                                    <li><strong>Greedy approach:</strong> Always pick minimum distance unvisited vertex</li>
                                    <li><strong>Time Complexity:</strong> O((V+E) log V) with min-heap, O(V¬≤) with array</li>
                                    <li><strong>Output:</strong> Shortest paths from source to all vertices</li>
                                    <li><strong>Relaxation:</strong> If d[v] > d[u] + w(u,v), update d[v]</li>
                                </ul>
                            </div>
                            <div class="video-recommendations">
                                <h4>Video Recommendations:</h4>
                                <a href="https://www.youtube.com/watch?v=XB4MIexjvY0" target="_blank" class="video-link">üé• Abdul Bari - Dijkstra's Algorithm (15 min)</a>
                                <a href="https://www.youtube.com/watch?v=pSqmAO-m7Lk" target="_blank" class="video-link">üé• William Fiset - Dijkstra's Shortest Path (12 min)</a>
                            </div>
                            <div class="warning-box">
                                <h4>Critical to Remember:</h4>
                                <p>Dijkstra's FAILS with negative weights! Use Bellman-Ford for negative weights (though this might not be on your exam based on syllabus).</p>
                            </div>
                            <div class="practice-tip">
                                <h4>Algorithm Steps:</h4>
                                <ol>
                                    <li>Initialize: d[source] = 0, d[all others] = ‚àû, min-heap with all vertices</li>
                                    <li>While heap not empty: extract min vertex u</li>
                                    <li>For each neighbor v of u: relax edge (u,v)</li>
                                    <li>Update heap if distance improved</li>
                                </ol>
                            </div>
                        </div>

                        <div class="quick-reference">
                            <h3>Graph Algorithms Quick Reference</h3>
                            <table class="complexity-table">
                                <thead>
                                    <tr>
                                        <th>Algorithm</th>
                                        <th>Time Complexity</th>
                                        <th>Space</th>
                                        <th>Key Use</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr>
                                        <td>BFS</td>
                                        <td>O(V + E)</td>
                                        <td>O(V)</td>
                                        <td>Shortest path (unweighted)</td>
                                    </tr>
                                    <tr>
                                        <td>DFS</td>
                                        <td>O(V + E)</td>
                                        <td>O(V)</td>
                                        <td>Cycle detection, topological sort</td>
                                    </tr>
                                    <tr>
                                        <td>Topological Sort</td>
                                        <td>O(V + E)</td>
                                        <td>O(V)</td>
                                        <td>Task scheduling (DAGs only)</td>
                                    </tr>
                                    <tr>
                                        <td>SCC (Kosaraju)</td>
                                        <td>O(V + E)</td>
                                        <td>O(V)</td>
                                        <td>Find strongly connected components</td>
                                    </tr>
                                    <tr>
                                        <td>Dijkstra</td>
                                        <td>O((V+E) log V)</td>
                                        <td>O(V)</td>
                                        <td>Shortest path (non-negative weights)</td>
                                    </tr>
                                </tbody>
                            </table>
                        </div>

                        <ul class="checklist">
                            <li><input type="checkbox" onchange="updateProgress()"> Understand graph representations</li>
                            <li><input type="checkbox" onchange="updateProgress()"> Can trace BFS step-by-step</li>
                            <li><input type="checkbox" onchange="updateProgress()"> Can trace DFS and identify edge types</li>
                            <li><input type="checkbox" onchange="updateProgress()"> Understand topological sort algorithm</li>
                            <li><input type="checkbox" onchange="updateProgress()"> Can execute Kosaraju's SCC algorithm</li>
                            <li><input type="checkbox" onchange="updateProgress()"> Can trace Dijkstra's algorithm</li>
                            <li><input type="checkbox" onchange="updateProgress()"> Review problem sets ps1-ps3</li>
                        </ul>

                        <div class="subtopic" style="margin-top: 40px;">
                            <h3>Interactive BFS/DFS Practice - Fill in the Order!</h3>
                            <p style="color: #555; margin-bottom: 20px;">Based on ps1: Click vertices in the order they would be visited. Test your understanding!</p>

                            <!-- BFS Exercise -->
                            <div class="trace-exercise">
                                <h4>Exercise 1: Breadth-First Search (Starting from A)</h4>
                                <p><strong>Instructions:</strong> Click vertices in the order BFS would visit them starting from node A. When multiple nodes can be enqueued, choose alphabetically.</p>

                                <svg width="650" height="400" viewBox="0 0 650 400" style="background: #f8f9fa; border-radius: 8px; margin: 20px 0;">
                                    <!-- Edges (drawn first, under nodes) -->
                                    <!-- A to B -->
                                    <line x1="100" y1="200" x2="200" y2="100" stroke="#ccc" stroke-width="2"/>
                                    <!-- A to H -->
                                    <line x1="100" y1="200" x2="200" y2="200" stroke="#ccc" stroke-width="2"/>
                                    <!-- A to F -->
                                    <line x1="100" y1="200" x2="200" y2="300" stroke="#ccc" stroke-width="2"/>
                                    <!-- B to D -->
                                    <line x1="200" y1="100" x2="400" y2="100" stroke="#ccc" stroke-width="2"/>
                                    <!-- H to C -->
                                    <line x1="200" y1="200" x2="350" y2="200" stroke="#ccc" stroke-width="2"/>
                                    <!-- H to E -->
                                    <line x1="200" y1="200" x2="300" y2="300" stroke="#ccc" stroke-width="2"/>
                                    <!-- C to D -->
                                    <line x1="350" y1="200" x2="400" y2="100" stroke="#ccc" stroke-width="2"/>
                                    <!-- C to G -->
                                    <line x1="350" y1="200" x2="500" y2="200" stroke="#ccc" stroke-width="2"/>
                                    <!-- D to G -->
                                    <line x1="400" y1="100" x2="500" y2="200" stroke="#ccc" stroke-width="2"/>
                                    <!-- F to E -->
                                    <line x1="200" y1="300" x2="300" y2="300" stroke="#ccc" stroke-width="2"/>

                                    <!-- Arrow markers for directed edges -->
                                    <defs>
                                        <marker id="arrowhead-bfs" markerWidth="10" markerHeight="10" refX="9" refY="3" orient="auto">
                                            <polygon points="0 0, 10 3, 0 6" fill="#666" />
                                        </marker>
                                    </defs>

                                    <!-- Add arrowheads to lines -->
                                    <line x1="120" y1="190" x2="180" y2="110" stroke="#666" stroke-width="1.5" marker-end="url(#arrowhead-bfs)"/>
                                    <line x1="125" y1="200" x2="175" y2="200" stroke="#666" stroke-width="1.5" marker-end="url(#arrowhead-bfs)"/>
                                    <line x1="120" y1="210" x2="180" y2="290" stroke="#666" stroke-width="1.5" marker-end="url(#arrowhead-bfs)"/>
                                    <line x1="220" y1="100" x2="375" y2="100" stroke="#666" stroke-width="1.5" marker-end="url(#arrowhead-bfs)"/>
                                    <line x1="225" y1="200" x2="325" y2="200" stroke="#666" stroke-width="1.5" marker-end="url(#arrowhead-bfs)"/>
                                    <line x1="215" y1="215" x2="285" y2="285" stroke="#666" stroke-width="1.5" marker-end="url(#arrowhead-bfs)"/>
                                    <line x1="365" y1="185" x2="395" y2="115" stroke="#666" stroke-width="1.5" marker-end="url(#arrowhead-bfs)"/>
                                    <line x1="375" y1="200" x2="475" y2="200" stroke="#666" stroke-width="1.5" marker-end="url(#arrowhead-bfs)"/>
                                    <line x1="415" y1="115" x2="485" y2="185" stroke="#666" stroke-width="1.5" marker-end="url(#arrowhead-bfs)"/>
                                    <line x1="220" y1="300" x2="275" y2="300" stroke="#666" stroke-width="1.5" marker-end="url(#arrowhead-bfs)"/>

                                    <!-- Nodes (clickable) -->
                                    <circle id="bfs-node-A" cx="100" cy="200" r="30" fill="#42a5f5" stroke="#0d47a1" stroke-width="3" style="cursor: pointer;" onclick="selectBFSNode('A', 0)"/>
                                    <text x="100" y="205" text-anchor="middle" fill="white" font-weight="bold" font-size="20">A</text>

                                    <circle id="bfs-node-B" cx="200" cy="100" r="30" fill="#e0e0e0" stroke="#666" stroke-width="3" style="cursor: pointer;" onclick="selectBFSNode('B', 1)"/>
                                    <text x="200" y="105" text-anchor="middle" fill="#333" font-weight="bold" font-size="20">B</text>

                                    <circle id="bfs-node-C" cx="350" cy="200" r="30" fill="#e0e0e0" stroke="#666" stroke-width="3" style="cursor: pointer;" onclick="selectBFSNode('C', 6)"/>
                                    <text x="350" y="205" text-anchor="middle" fill="#333" font-weight="bold" font-size="20">C</text>

                                    <circle id="bfs-node-D" cx="400" cy="100" r="30" fill="#e0e0e0" stroke="#666" stroke-width="3" style="cursor: pointer;" onclick="selectBFSNode('D', 4)"/>
                                    <text x="400" y="105" text-anchor="middle" fill="#333" font-weight="bold" font-size="20">D</text>

                                    <circle id="bfs-node-E" cx="300" cy="300" r="30" fill="#e0e0e0" stroke="#666" stroke-width="3" style="cursor: pointer;" onclick="selectBFSNode('E', 5)"/>
                                    <text x="300" y="305" text-anchor="middle" fill="#333" font-weight="bold" font-size="20">E</text>

                                    <circle id="bfs-node-F" cx="200" cy="300" r="30" fill="#e0e0e0" stroke="#666" stroke-width="3" style="cursor: pointer;" onclick="selectBFSNode('F', 2)"/>
                                    <text x="200" y="305" text-anchor="middle" fill="#333" font-weight="bold" font-size="20">F</text>

                                    <circle id="bfs-node-G" cx="500" cy="200" r="30" fill="#e0e0e0" stroke="#666" stroke-width="3" style="cursor: pointer;" onclick="selectBFSNode('G', 7)"/>
                                    <text x="500" y="205" text-anchor="middle" fill="#333" font-weight="bold" font-size="20">G</text>

                                    <circle id="bfs-node-H" cx="200" cy="200" r="30" fill="#e0e0e0" stroke="#666" stroke-width="3" style="cursor: pointer;" onclick="selectBFSNode('H', 3)"/>
                                    <text x="200" y="205" text-anchor="middle" fill="#333" font-weight="bold" font-size="20">H</text>
                                </svg>

                                <div id="bfs-selection-order" style="margin: 20px 0; padding: 15px; background: #e3f2fd; border-radius: 8px;">
                                    <strong>Your BFS order:</strong> <span id="bfs-selections">Click on A to start...</span>
                                </div>

                                <button onclick="checkBFSAnswer()" style="background: #1565c0; color: white; border: none; padding: 12px 24px; border-radius: 4px; cursor: pointer; font-size: 16px; margin-right: 10px;">Check Answer</button>
                                <button onclick="resetBFSExercise()" style="background: #666; color: white; border: none; padding: 12px 24px; border-radius: 4px; cursor: pointer; font-size: 16px;">Reset</button>

                                <div id="bfs-feedback" style="margin-top: 20px; padding: 15px; border-radius: 8px; display: none;"></div>

                                <div class="answer-reveal" style="margin-top: 20px;">
                                    <button onclick="toggleAnswer('bfs-ps1-answer')" style="background: #0d47a1; color: white; border: none; padding: 10px 20px; border-radius: 4px; cursor: pointer;">Show/Hide Solution</button>
                                    <div id="bfs-ps1-answer" class="answer-content">
                                        <h4>Correct BFS Order from A:</h4>
                                        <p><strong>A ‚Üí B ‚Üí F ‚Üí H ‚Üí D ‚Üí E ‚Üí C ‚Üí G</strong></p>
                                        <h5>Step-by-Step Explanation:</h5>
                                        <ol>
                                            <li><strong>Start at A:</strong> Enqueue A, mark as visited</li>
                                            <li><strong>Process A:</strong> Neighbors are B, F, H (alphabetically: B, F, H). Enqueue all three.</li>
                                            <li><strong>Queue: [B, F, H]</strong></li>
                                            <li><strong>Process B:</strong> Dequeue B. Neighbor is D. Enqueue D.</li>
                                            <li><strong>Queue: [F, H, D]</strong></li>
                                            <li><strong>Process F:</strong> Dequeue F. Neighbor is E. Enqueue E.</li>
                                            <li><strong>Queue: [H, D, E]</strong></li>
                                            <li><strong>Process H:</strong> Dequeue H. Neighbors are C, E (E already visited). Enqueue C.</li>
                                            <li><strong>Queue: [D, E, C]</strong></li>
                                            <li><strong>Process D:</strong> Dequeue D. Neighbor is G. Enqueue G.</li>
                                            <li><strong>Queue: [E, C, G]</strong></li>
                                            <li><strong>Process E, C, G:</strong> No new unvisited neighbors.</li>
                                        </ol>
                                        <p><em>Remember: When multiple nodes are at the same level, enqueue alphabetically!</em></p>
                                    </div>
                                </div>
                            </div>

                            <!-- DFS Exercise -->
                            <div class="trace-exercise" style="margin-top: 40px;">
                                <h4>Exercise 2: Depth-First Search (Starting from A)</h4>
                                <p><strong>Instructions:</strong> Click vertices in the order DFS would visit them starting from node A. When multiple nodes can be explored, choose alphabetically.</p>

                                <svg width="650" height="400" viewBox="0 0 650 400" style="background: #f8f9fa; border-radius: 8px; margin: 20px 0;">
                                    <!-- Same graph structure as BFS -->
                                    <!-- Edges -->
                                    <line x1="100" y1="200" x2="200" y2="100" stroke="#ccc" stroke-width="2"/>
                                    <line x1="100" y1="200" x2="200" y2="200" stroke="#ccc" stroke-width="2"/>
                                    <line x1="100" y1="200" x2="200" y2="300" stroke="#ccc" stroke-width="2"/>
                                    <line x1="200" y1="100" x2="400" y2="100" stroke="#ccc" stroke-width="2"/>
                                    <line x1="200" y1="200" x2="350" y2="200" stroke="#ccc" stroke-width="2"/>
                                    <line x1="200" y1="200" x2="300" y2="300" stroke="#ccc" stroke-width="2"/>
                                    <line x1="350" y1="200" x2="400" y2="100" stroke="#ccc" stroke-width="2"/>
                                    <line x1="350" y1="200" x2="500" y2="200" stroke="#ccc" stroke-width="2"/>
                                    <line x1="400" y1="100" x2="500" y2="200" stroke="#ccc" stroke-width="2"/>
                                    <line x1="200" y1="300" x2="300" y2="300" stroke="#ccc" stroke-width="2"/>

                                    <!-- Arrow markers -->
                                    <defs>
                                        <marker id="arrowhead-dfs" markerWidth="10" markerHeight="10" refX="9" refY="3" orient="auto">
                                            <polygon points="0 0, 10 3, 0 6" fill="#666" />
                                        </marker>
                                    </defs>

                                    <line x1="120" y1="190" x2="180" y2="110" stroke="#666" stroke-width="1.5" marker-end="url(#arrowhead-dfs)"/>
                                    <line x1="125" y1="200" x2="175" y2="200" stroke="#666" stroke-width="1.5" marker-end="url(#arrowhead-dfs)"/>
                                    <line x1="120" y1="210" x2="180" y2="290" stroke="#666" stroke-width="1.5" marker-end="url(#arrowhead-dfs)"/>
                                    <line x1="220" y1="100" x2="375" y2="100" stroke="#666" stroke-width="1.5" marker-end="url(#arrowhead-dfs)"/>
                                    <line x1="225" y1="200" x2="325" y2="200" stroke="#666" stroke-width="1.5" marker-end="url(#arrowhead-dfs)"/>
                                    <line x1="215" y1="215" x2="285" y2="285" stroke="#666" stroke-width="1.5" marker-end="url(#arrowhead-dfs)"/>
                                    <line x1="365" y1="185" x2="395" y2="115" stroke="#666" stroke-width="1.5" marker-end="url(#arrowhead-dfs)"/>
                                    <line x1="375" y1="200" x2="475" y2="200" stroke="#666" stroke-width="1.5" marker-end="url(#arrowhead-dfs)"/>
                                    <line x1="415" y1="115" x2="485" y2="185" stroke="#666" stroke-width="1.5" marker-end="url(#arrowhead-dfs)"/>
                                    <line x1="220" y1="300" x2="275" y2="300" stroke="#666" stroke-width="1.5" marker-end="url(#arrowhead-dfs)"/>

                                    <!-- Nodes -->
                                    <circle id="dfs-node-A" cx="100" cy="200" r="30" fill="#4caf50" stroke="#2e7d32" stroke-width="3" style="cursor: pointer;" onclick="selectDFSNode('A', 0)"/>
                                    <text x="100" y="205" text-anchor="middle" fill="white" font-weight="bold" font-size="20">A</text>

                                    <circle id="dfs-node-B" cx="200" cy="100" r="30" fill="#e0e0e0" stroke="#666" stroke-width="3" style="cursor: pointer;" onclick="selectDFSNode('B', 1)"/>
                                    <text x="200" y="105" text-anchor="middle" fill="#333" font-weight="bold" font-size="20">B</text>

                                    <circle id="dfs-node-C" cx="350" cy="200" r="30" fill="#e0e0e0" stroke="#666" stroke-width="3" style="cursor: pointer;" onclick="selectDFSNode('C', 7)"/>
                                    <text x="350" y="205" text-anchor="middle" fill="#333" font-weight="bold" font-size="20">C</text>

                                    <circle id="dfs-node-D" cx="400" cy="100" r="30" fill="#e0e0e0" stroke="#666" stroke-width="3" style="cursor: pointer;" onclick="selectDFSNode('D', 2)"/>
                                    <text x="400" y="105" text-anchor="middle" fill="#333" font-weight="bold" font-size="20">D</text>

                                    <circle id="dfs-node-E" cx="300" cy="300" r="30" fill="#e0e0e0" stroke="#666" stroke-width="3" style="cursor: pointer;" onclick="selectDFSNode('E', 5)"/>
                                    <text x="300" y="305" text-anchor="middle" fill="#333" font-weight="bold" font-size="20">E</text>

                                    <circle id="dfs-node-F" cx="200" cy="300" r="30" fill="#e0e0e0" stroke="#666" stroke-width="3" style="cursor: pointer;" onclick="selectDFSNode('F', 4)"/>
                                    <text x="200" y="305" text-anchor="middle" fill="#333" font-weight="bold" font-size="20">F</text>

                                    <circle id="dfs-node-G" cx="500" cy="200" r="30" fill="#e0e0e0" stroke="#666" stroke-width="3" style="cursor: pointer;" onclick="selectDFSNode('G', 3)"/>
                                    <text x="500" y="205" text-anchor="middle" fill="#333" font-weight="bold" font-size="20">G</text>

                                    <circle id="dfs-node-H" cx="200" cy="200" r="30" fill="#e0e0e0" stroke="#666" stroke-width="3" style="cursor: pointer;" onclick="selectDFSNode('H', 6)"/>
                                    <text x="200" y="205" text-anchor="middle" fill="#333" font-weight="bold" font-size="20">H</text>
                                </svg>

                                <div id="dfs-selection-order" style="margin: 20px 0; padding: 15px; background: #e8f5e9; border-radius: 8px;">
                                    <strong>Your DFS order:</strong> <span id="dfs-selections">Click on A to start...</span>
                                </div>

                                <button onclick="checkDFSAnswer()" style="background: #2e7d32; color: white; border: none; padding: 12px 24px; border-radius: 4px; cursor: pointer; font-size: 16px; margin-right: 10px;">Check Answer</button>
                                <button onclick="resetDFSExercise()" style="background: #666; color: white; border: none; padding: 12px 24px; border-radius: 4px; cursor: pointer; font-size: 16px;">Reset</button>

                                <div id="dfs-feedback" style="margin-top: 20px; padding: 15px; border-radius: 8px; display: none;"></div>

                                <div class="answer-reveal" style="margin-top: 20px;">
                                    <button onclick="toggleAnswer('dfs-ps1-answer')" style="background: #1b5e20; color: white; border: none; padding: 10px 20px; border-radius: 4px; cursor: pointer;">Show/Hide Solution</button>
                                    <div id="dfs-ps1-answer" class="answer-content">
                                        <h4>Correct DFS Order from A:</h4>
                                        <p><strong>A ‚Üí B ‚Üí D ‚Üí G ‚Üí F ‚Üí E ‚Üí H ‚Üí C</strong></p>
                                        <h5>Step-by-Step Explanation:</h5>
                                        <ol>
                                            <li><strong>Start at A:</strong> Mark A as visited. Neighbors: B, F, H (alphabetically)</li>
                                            <li><strong>Visit B (first alphabetically):</strong> From A ‚Üí B. Neighbor: D</li>
                                            <li><strong>Visit D:</strong> From B ‚Üí D. Neighbor: G</li>
                                            <li><strong>Visit G:</strong> From D ‚Üí G. No unvisited neighbors, backtrack to D, then B, then A</li>
                                            <li><strong>Visit F (next alphabetically from A):</strong> From A ‚Üí F. Neighbor: E</li>
                                            <li><strong>Visit E:</strong> From F ‚Üí E. No unvisited neighbors, backtrack to F, then A</li>
                                            <li><strong>Visit H (last from A):</strong> From A ‚Üí H. Neighbors: C, E (E already visited)</li>
                                            <li><strong>Visit C:</strong> From H ‚Üí C. Neighbors already visited (D, G)</li>
                                        </ol>
                                        <p><strong>Stack trace:</strong> A ‚Üí [B,F,H] ‚Üí B ‚Üí [D] ‚Üí D ‚Üí [G] ‚Üí G ‚Üí backtrack ‚Üí F ‚Üí [E] ‚Üí E ‚Üí backtrack ‚Üí H ‚Üí [C] ‚Üí C ‚Üí done</p>
                                        <p><em>DFS explores as deep as possible before backtracking!</em></p>
                                    </div>
                                </div>
                            </div>

                            <!-- Comparison Note -->
                            <div class="practice-tip" style="margin-top: 30px;">
                                <h4>Key Differences:</h4>
                                <ul>
                                    <li><strong>BFS Order:</strong> A ‚Üí B ‚Üí F ‚Üí H ‚Üí D ‚Üí E ‚Üí C ‚Üí G (explores level-by-level)</li>
                                    <li><strong>DFS Order:</strong> A ‚Üí B ‚Üí D ‚Üí G ‚Üí F ‚Üí E ‚Üí H ‚Üí C (explores depth-first)</li>
                                </ul>
                                <p><strong>BFS uses a Queue</strong> (FIFO - processes closest nodes first), while <strong>DFS uses a Stack/Recursion</strong> (LIFO - goes as deep as possible first).</p>
                                <p>Both visit all reachable nodes, but in very different orders!</p>
                            </div>
                        </div>

                        <script>
                            // BFS algorithm exercise logic
                            let bfsSelections = [];
                            const bfsCorrectOrder = ['A', 'B', 'F', 'H', 'D', 'E', 'C', 'G'];
                            let bfsStarted = false;

                            function selectBFSNode(node, correctIndex) {
                                if (bfsSelections.includes(node)) {
                                    alert('You already visited this node!');
                                    return;
                                }

                                if (!bfsStarted && node !== 'A') {
                                    alert('You must start at node A!');
                                    return;
                                }

                                bfsSelections.push(node);
                                bfsStarted = true;

                                // Color the node based on order
                                const colors = ['#42a5f5', '#64b5f6', '#90caf9', '#bbdefb', '#e3f2fd', '#fff3e0', '#ffe0b2', '#ffcc80'];
                                document.getElementById('bfs-node-' + node).setAttribute('fill', colors[bfsSelections.length - 1]);

                                updateBFSDisplay();
                            }

                            function updateBFSDisplay() {
                                const display = bfsSelections.join(' ‚Üí ');
                                document.getElementById('bfs-selections').textContent = display || 'Click on A to start...';
                            }

                            function checkBFSAnswer() {
                                const feedback = document.getElementById('bfs-feedback');
                                feedback.style.display = 'block';

                                if (bfsSelections.length !== 8) {
                                    feedback.style.background = '#fff3cd';
                                    feedback.style.color = '#856404';
                                    feedback.innerHTML = '<strong>Not complete!</strong> You need to visit all 8 vertices.';
                                    return;
                                }

                                let allCorrect = true;
                                let feedbackHTML = '<strong>Results:</strong><ul>';

                                for (let i = 0; i < bfsSelections.length; i++) {
                                    const isCorrect = bfsSelections[i] === bfsCorrectOrder[i];
                                    allCorrect = allCorrect && isCorrect;
                                    feedbackHTML += `<li>Position ${i + 1}: ${bfsSelections[i]} - ${isCorrect ? '‚úì Correct!' : '‚úó Should be ' + bfsCorrectOrder[i]}</li>`;
                                }

                                feedbackHTML += '</ul>';

                                if (allCorrect) {
                                    feedback.style.background = '#d4edda';
                                    feedback.style.color = '#155724';
                                    feedbackHTML = '<strong>Perfect! üéâ</strong> You correctly traced BFS!' + feedbackHTML;
                                } else {
                                    feedback.style.background = '#f8d7da';
                                    feedback.style.color = '#721c24';
                                    feedbackHTML = '<strong>Not quite right.</strong> Review the steps below:' + feedbackHTML;
                                }

                                feedback.innerHTML = feedbackHTML;
                            }

                            function resetBFSExercise() {
                                bfsSelections = [];
                                bfsStarted = false;
                                updateBFSDisplay();
                                document.getElementById('bfs-feedback').style.display = 'none';

                                // Reset node colors
                                const nodes = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H'];
                                nodes.forEach(node => {
                                    const el = document.getElementById('bfs-node-' + node);
                                    if (el) {
                                        if (node === 'A') {
                                            el.setAttribute('fill', '#42a5f5');
                                        } else {
                                            el.setAttribute('fill', '#e0e0e0');
                                        }
                                    }
                                });
                            }

                            // DFS algorithm exercise logic
                            let dfsSelections = [];
                            const dfsCorrectOrder = ['A', 'B', 'D', 'G', 'F', 'E', 'H', 'C'];
                            let dfsStarted = false;

                            function selectDFSNode(node, correctIndex) {
                                if (dfsSelections.includes(node)) {
                                    alert('You already visited this node!');
                                    return;
                                }

                                if (!dfsStarted && node !== 'A') {
                                    alert('You must start at node A!');
                                    return;
                                }

                                dfsSelections.push(node);
                                dfsStarted = true;

                                // Color the node
                                const colors = ['#4caf50', '#66bb6a', '#81c784', '#a5d6a7', '#c8e6c9', '#dcedc8', '#f1f8e9', '#f9fbe7'];
                                document.getElementById('dfs-node-' + node).setAttribute('fill', colors[dfsSelections.length - 1]);

                                updateDFSDisplay();
                            }

                            function updateDFSDisplay() {
                                const display = dfsSelections.join(' ‚Üí ');
                                document.getElementById('dfs-selections').textContent = display || 'Click on A to start...';
                            }

                            function checkDFSAnswer() {
                                const feedback = document.getElementById('dfs-feedback');
                                feedback.style.display = 'block';

                                if (dfsSelections.length !== 8) {
                                    feedback.style.background = '#fff3cd';
                                    feedback.style.color = '#856404';
                                    feedback.innerHTML = '<strong>Not complete!</strong> You need to visit all 8 vertices.';
                                    return;
                                }

                                let allCorrect = true;
                                let feedbackHTML = '<strong>Results:</strong><ul>';

                                for (let i = 0; i < dfsSelections.length; i++) {
                                    const isCorrect = dfsSelections[i] === dfsCorrectOrder[i];
                                    allCorrect = allCorrect && isCorrect;
                                    feedbackHTML += `<li>Position ${i + 1}: ${dfsSelections[i]} - ${isCorrect ? '‚úì Correct!' : '‚úó Should be ' + dfsCorrectOrder[i]}</li>`;
                                }

                                feedbackHTML += '</ul>';

                                if (allCorrect) {
                                    feedback.style.background = '#d4edda';
                                    feedback.style.color = '#155724';
                                    feedbackHTML = '<strong>Excellent! üéâ</strong> You correctly traced DFS!' + feedbackHTML;
                                } else {
                                    feedback.style.background = '#f8d7da';
                                    feedback.style.color = '#721c24';
                                    feedbackHTML = '<strong>Not quite right.</strong> Review the steps below:' + feedbackHTML;
                                }

                                feedback.innerHTML = feedbackHTML;
                            }

                            function resetDFSExercise() {
                                dfsSelections = [];
                                dfsStarted = false;
                                updateDFSDisplay();
                                document.getElementById('dfs-feedback').style.display = 'none';

                                // Reset node colors
                                const nodes = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H'];
                                nodes.forEach(node => {
                                    const el = document.getElementById('dfs-node-' + node);
                                    if (el) {
                                        if (node === 'A') {
                                            el.setAttribute('fill', '#4caf50');
                                        } else {
                                            el.setAttribute('fill', '#e0e0e0');
                                        }
                                    }
                                });
                            }
                        </script>
</div>
    </div>

    <!-- Footer -->
    <footer>
        <p>Good luck on your final exam! üöÄ</p>
        <p style="font-size: 0.9em; margin-top: 10px;">Platform generated with Claude Code</p>
    </footer>

    <script src="scripts.js"></script>
</body>
</html>
