<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Algorithm Formulas & Reference - DSA Study Platform</title>
    <link rel="stylesheet" href="styles.css">
    <style>
        .algorithm-card {
            background: white;
            border: 2px solid #0d47a1;
            border-radius: 8px;
            padding: 20px;
            margin: 20px 0;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .algorithm-header {
            background: linear-gradient(135deg, #1565c0 0%, #0d47a1 100%);
            color: white;
            padding: 15px;
            border-radius: 6px;
            margin-bottom: 15px;
        }
        .formula-section {
            margin: 15px 0;
            padding: 15px;
            background: #f5f5f5;
            border-left: 4px solid #42a5f5;
            border-radius: 4px;
        }
        .decision-box {
            background: #fff3e0;
            border: 3px solid #ff9800;
            border-radius: 8px;
            padding: 15px;
            margin: 15px 0;
        }
        .decision-box h4 {
            color: #e65100;
            margin-top: 0;
        }
        .formula-section h4 {
            margin-top: 0;
            color: #0d47a1;
        }
        .formula {
            font-family: 'Courier New', monospace;
            background: #e3f2fd;
            padding: 10px;
            border-radius: 4px;
            margin: 10px 0;
            overflow-x: auto;
        }
        .complexity-badge {
            display: inline-block;
            background: #4caf50;
            color: white;
            padding: 5px 12px;
            border-radius: 20px;
            font-weight: bold;
            margin: 5px;
        }
        .when-to-use {
            background: #e8f5e9;
            border-left: 4px solid #4caf50;
            padding: 15px;
            margin: 15px 0;
            border-radius: 4px;
        }
        .variable-table {
            width: 100%;
            border-collapse: collapse;
            margin: 10px 0;
        }
        .variable-table th,
        .variable-table td {
            border: 1px solid #ddd;
            padding: 10px;
            text-align: left;
        }
        .variable-table th {
            background: #1565c0;
            color: white;
        }
        .variable-table tr:nth-child(even) {
            background: #f5f5f5;
        }
        .task-category {
            background: linear-gradient(135deg, #0d47a1 0%, #1565c0 100%);
            color: white;
            padding: 20px;
            border-radius: 8px;
            margin: 30px 0 20px 0;
        }
    </style>
</head>
<body>
    <!-- Navigation Bar -->
    <nav class="navbar">
        <div class="nav-container">
            <a href="home.html" class="nav-brand">DSA Study Platform</a>
            <div class="menu-toggle" onclick="toggleMenu()">
                <span></span>
                <span></span>
                <span></span>
            </div>
            <ul class="nav-menu" id="navMenu">
                <li class="nav-item"><a href="home.html" class="nav-link">Home</a></li>
                <li class="nav-item"><a href="graphs.html" class="nav-link">Graphs</a></li>
                <li class="nav-item"><a href="divide-conquer.html" class="nav-link">Divide & Conquer</a></li>
                <li class="nav-item"><a href="greedy.html" class="nav-link">Greedy</a></li>
                <li class="nav-item"><a href="dynamic-programming.html" class="nav-link">Dynamic Programming</a></li>
                <li class="nav-item"><a href="max-flow.html" class="nav-link">Max Flow</a></li>
                <li class="nav-item"><a href="formulas.html" class="nav-link active">Formulas</a></li>
                <li class="nav-item"><a href="practice-exam.html" class="nav-link">Practice Exam</a></li>
                <li class="nav-item"><a href="practice-quiz5.html" class="nav-link">Quiz 5 Practice</a></li>                <li class="nav-item"><a href="review.html" class="nav-link">Final Review</a></li>
            </ul>
        </div>
    </nav>

    <!-- Header -->
    <header>
        <h1>Complete Algorithm Reference</h1>
        <p class="subtitle">Organized by Task - All Formulas, Decision Rules, and Complexities</p>
    </header>

    <div class="container">
        <!-- Table of Contents -->
        <div class="subtopic">
            <h3>Quick Navigation by Task</h3>
            <ul style="columns: 2;">
                <li><a href="#shortest-path">Shortest Path Problems</a></li>
                <li><a href="#graph-traversal">Graph Traversal & Ordering</a></li>
                <li><a href="#mst">Minimum Spanning Tree</a></li>
                <li><a href="#greedy-opt">Greedy Optimization</a></li>
                <li><a href="#dp-opt">Dynamic Programming Optimization</a></li>
                <li><a href="#flow">Network Flow</a></li>
                <li><a href="#divide-conquer">Divide and Conquer</a></li>
            </ul>
        </div>

        <!-- SHORTEST PATH PROBLEMS -->
        <div class="task-category" id="shortest-path">
            <h2>TASK: Finding Shortest Paths</h2>
            <p>Algorithms for finding shortest paths from source to other vertices</p>
        </div>

        <div class="subtopic">
            <!-- BFS for Shortest Path -->
            <div class="algorithm-card">
                <div class="algorithm-header">
                    <h3>BFS (Breadth-First Search)</h3>
                    <p style="margin: 5px 0 0 0; opacity: 0.9;">For unweighted graphs</p>
                </div>

                <div class="complexity-badge">Time: O(V + E)</div>
                <div class="complexity-badge" style="background: #2196f3;">Space: O(V)</div>

                <div class="decision-box">
                    <h4>üéØ Decision Rule (Formulaic):</h4>
                    <div class="formula">
                        At each step:
                        CHOOSE: Next vertex u from front of queue
                        FOR EACH: unvisited neighbor v of u
                            ENQUEUE(v)
                            d[v] = d[u] + 1
                    </div>
                    <p><strong>Why this rule?</strong> Queue ensures FIFO ‚Üí explores vertices level by level ‚Üí guarantees shortest path in unweighted graphs</p>
                </div>

                <div class="when-to-use">
                    <h4>When to Use:</h4>
                    <ul>
                        <li>Finding shortest path in <strong>unweighted</strong> graphs</li>
                        <li>Finding minimum number of edges between vertices</li>
                        <li>Level-order traversal</li>
                    </ul>
                </div>

                <div class="formula-section">
                    <h4>Distance Formula:</h4>
                    <div class="formula">
                        d[v] = d[u] + 1 where u is parent of v in BFS tree

                        Base case: d[s] = 0 for source s
                    </div>
                </div>

                <div class="formula-section">
                    <h4>Variables:</h4>
                    <table class="variable-table">
                        <tr>
                            <th>Variable</th>
                            <th>Meaning</th>
                        </tr>
                        <tr>
                            <td>V</td>
                            <td>Number of vertices</td>
                        </tr>
                        <tr>
                            <td>E</td>
                            <td>Number of edges</td>
                        </tr>
                        <tr>
                            <td>d[v]</td>
                            <td>Distance (number of edges) from source to v</td>
                        </tr>
                        <tr>
                            <td>Q</td>
                            <td>Queue of vertices to visit</td>
                        </tr>
                    </table>
                </div>
            </div>

            <!-- Dijkstra's Algorithm -->
            <div class="algorithm-card">
                <div class="algorithm-header">
                    <h3>Dijkstra's Algorithm</h3>
                    <p style="margin: 5px 0 0 0; opacity: 0.9;">For weighted graphs with non-negative weights</p>
                </div>

                <div class="complexity-badge">Time: O((V+E) log V)</div>
                <div class="complexity-badge" style="background: #2196f3;">Space: O(V)</div>

                <div class="decision-box">
                    <h4>üéØ Decision Rule (Formulaic):</h4>
                    <div class="formula">
                        At each step:
                        CHOOSE: u = argmin{d[v] : v not yet finalized}
                                (vertex with minimum distance estimate)

                        FOR EACH: neighbor v of u
                            IF d[v] > d[u] + w(u,v):  ‚Üê RELAXATION
                                d[v] = d[u] + w(u,v)
                                œÄ[v] = u
                    </div>
                    <p><strong>Why this rule?</strong> Greedy choice of minimum distance is safe because all weights are non-negative ‚Üí cannot find shorter path later</p>
                </div>

                <div class="when-to-use">
                    <h4>When to Use:</h4>
                    <ul>
                        <li>Finding shortest paths in <strong>weighted</strong> graphs</li>
                        <li><strong>ONLY</strong> when all edge weights are <strong>non-negative</strong></li>
                        <li>Single-source shortest paths (from one source to all vertices)</li>
                        <li>GPS navigation, network routing</li>
                    </ul>
                </div>

                <div class="formula-section">
                    <h4>Relaxation Formula (Core Decision):</h4>
                    <div class="formula">
                        RELAX(u, v, w):
                            if d[v] > d[u] + w(u,v):
                                d[v] = d[u] + w(u,v)
                                œÄ[v] = u
                                decreaseKey(Q, v, d[v])  // update priority queue
                    </div>
                </div>

                <div class="formula-section">
                    <h4>Variables:</h4>
                    <table class="variable-table">
                        <tr>
                            <th>Variable</th>
                            <th>Meaning</th>
                        </tr>
                        <tr>
                            <td>d[v]</td>
                            <td>Current shortest distance estimate from source to v</td>
                        </tr>
                        <tr>
                            <td>œÄ[v]</td>
                            <td>Predecessor of v in shortest path tree</td>
                        </tr>
                        <tr>
                            <td>w(u,v)</td>
                            <td>Weight of edge from u to v (must be ‚â• 0)</td>
                        </tr>
                        <tr>
                            <td>Q</td>
                            <td>Min-priority queue keyed by d[v]</td>
                        </tr>
                    </table>
                </div>

                <div class="formula-section">
                    <h4>Complete Algorithm:</h4>
                    <div class="formula">
                        INITIALIZE:
                            d[s] = 0
                            d[v] = ‚àû for all v ‚â† s
                            œÄ[v] = NIL for all v
                            Q = all vertices with key d[v]

                        WHILE Q ‚â† ‚àÖ:
                            u = extractMin(Q)
                            FOR EACH neighbor v of u:
                                RELAX(u, v, w)
                    </div>
                </div>
            </div>
        </div>

        <!-- GRAPH TRAVERSAL & ORDERING -->
        <div class="task-category" id="graph-traversal">
            <h2>TASK: Graph Traversal & Ordering</h2>
            <p>Algorithms for exploring graphs and establishing orderings</p>
        </div>

        <div class="subtopic">
            <!-- DFS -->
            <div class="algorithm-card">
                <div class="algorithm-header">
                    <h3>DFS (Depth-First Search)</h3>
                    <p style="margin: 5px 0 0 0; opacity: 0.9;">For deep exploration and cycle detection</p>
                </div>

                <div class="complexity-badge">Time: O(V + E)</div>
                <div class="complexity-badge" style="background: #2196f3;">Space: O(V)</div>

                <div class="decision-box">
                    <h4>üéØ Decision Rule (Formulaic):</h4>
                    <div class="formula">
                        At each step:
                        CHOOSE: First unvisited neighbor v of current vertex u
                        IF no unvisited neighbors:
                            BACKTRACK to parent

                        Recursively: DFS(v)
                    </div>
                    <p><strong>Why this rule?</strong> Stack/recursion ensures LIFO ‚Üí explores as deep as possible before backtracking</p>
                </div>

                <div class="when-to-use">
                    <h4>When to Use:</h4>
                    <ul>
                        <li>Topological sorting (for DAGs)</li>
                        <li>Finding strongly connected components</li>
                        <li>Cycle detection</li>
                        <li>Path finding (when all paths needed, not just shortest)</li>
                    </ul>
                </div>

                <div class="formula-section">
                    <h4>Timestamps:</h4>
                    <div class="formula">
                        d[v] = discovery time (when first visited)
                        f[v] = finish time (when all descendants explored)

                        Property: d[u] < d[v] < f[v] < f[u] iff v is descendant of u
                    </div>
                </div>
            </div>

            <!-- Topological Sort -->
            <div class="algorithm-card">
                <div class="algorithm-header">
                    <h3>Topological Sort</h3>
                    <p style="margin: 5px 0 0 0; opacity: 0.9;">For ordering dependent tasks (DAGs only)</p>
                </div>

                <div class="complexity-badge">Time: O(V + E)</div>
                <div class="complexity-badge" style="background: #2196f3;">Space: O(V)</div>

                <div class="decision-box">
                    <h4>üéØ Decision Rule (Formulaic):</h4>
                    <div class="formula">
                        At each step:
                        WHEN vertex v finishes in DFS (all descendants explored):
                            PUSH v onto stack S

                        FINAL ORDER: Pop all vertices from S
                    </div>
                    <p><strong>Why this rule?</strong> Vertices with later finish times have no outgoing edges to vertices with earlier finish times ‚Üí correct topological order</p>
                </div>

                <div class="when-to-use">
                    <h4>When to Use:</h4>
                    <ul>
                        <li>Scheduling tasks with dependencies</li>
                        <li>Course prerequisite ordering</li>
                        <li><strong>ONLY works on DAGs (Directed Acyclic Graphs)</strong></li>
                    </ul>
                </div>

                <div class="formula-section">
                    <h4>Correctness Property:</h4>
                    <div class="formula">
                        For any edge (u,v): f[u] > f[v]
                        Therefore, u appears before v in topological order
                    </div>
                </div>
            </div>

            <!-- SCC -->
            <div class="algorithm-card">
                <div class="algorithm-header">
                    <h3>Strongly Connected Components (Kosaraju's)</h3>
                    <p style="margin: 5px 0 0 0; opacity: 0.9;">For finding maximal strongly connected subgraphs</p>
                </div>

                <div class="complexity-badge">Time: O(V + E)</div>
                <div class="complexity-badge" style="background: #2196f3;">Space: O(V)</div>

                <div class="decision-box">
                    <h4>üéØ Decision Rule (Formulaic):</h4>
                    <div class="formula">
                        Pass 1: DFS on G, compute finish times f[v]
                        Pass 2: DFS on G^T in decreasing order of f[v]

                        CHOOSE: In Pass 2, start new DFS from vertex with max f[v]
                                among unvisited vertices

                        Each DFS tree in Pass 2 = one SCC
                    </div>
                </div>

                <div class="formula-section">
                    <h4>Algorithm:</h4>
                    <ol>
                        <li>Run DFS on G, compute f[v] for all v</li>
                        <li>Compute G^T (transpose - reverse all edges)</li>
                        <li>Run DFS on G^T, processing vertices in decreasing f[v] order</li>
                        <li>Each DFS tree = one SCC</li>
                    </ol>
                </div>
            </div>
        </div>

        <!-- MINIMUM SPANNING TREE -->
        <div class="task-category" id="mst">
            <h2>TASK: Minimum Spanning Tree</h2>
            <p>Algorithms for connecting all vertices with minimum total edge weight</p>
        </div>

        <div class="subtopic">
            <!-- Kruskal's -->
            <div class="algorithm-card">
                <div class="algorithm-header">
                    <h3>Kruskal's Algorithm (Edge-Based MST)</h3>
                </div>

                <div class="complexity-badge">Time: O(E log E)</div>
                <div class="complexity-badge" style="background: #2196f3;">Space: O(V)</div>

                <div class="decision-box">
                    <h4>üéØ Decision Rule (Formulaic):</h4>
                    <div class="formula">
                        SORT all edges by weight: w(e‚ÇÅ) ‚â§ w(e‚ÇÇ) ‚â§ ... ‚â§ w(e‚Çò)

                        FOR EACH edge (u,v) in sorted order:
                            CHOOSE (u,v) IF Find(u) ‚â† Find(v)
                                         (doesn't create cycle)
                            IF chosen:
                                A = A ‚à™ {(u,v)}
                                Union(u, v)

                        STOP when |A| = V - 1
                    </div>
                    <p><strong>Why this rule?</strong> Minimum weight edge that doesn't create cycle is always safe to add (Cut Property)</p>
                </div>

                <div class="when-to-use">
                    <h4>When to Use Kruskal's vs Prim's:</h4>
                    <ul>
                        <li>Kruskal's better for <strong>sparse graphs</strong> (few edges)</li>
                        <li>Kruskal's good when edges already sorted</li>
                        <li>Easier to parallelize than Prim's</li>
                    </ul>
                </div>

                <div class="formula-section">
                    <h4>MST Properties:</h4>
                    <ul>
                        <li>Has exactly V-1 edges</li>
                        <li>Connects all vertices (spanning)</li>
                        <li>No cycles (tree)</li>
                        <li>Total weight = Œ£ w(e) is minimum</li>
                    </ul>
                </div>
            </div>

            <!-- Prim's -->
            <div class="algorithm-card">
                <div class="algorithm-header">
                    <h3>Prim's Algorithm (Vertex-Based MST)</h3>
                </div>

                <div class="complexity-badge">Time: O((V+E) log V)</div>
                <div class="complexity-badge" style="background: #2196f3;">Space: O(V)</div>

                <div class="decision-box">
                    <h4>üéØ Decision Rule (Formulaic):</h4>
                    <div class="formula">
                        At each step:
                        CHOOSE: u = argmin{key[v] : v ‚àâ MST}
                                (vertex not in MST with minimum edge to MST)

                        ADD u to MST

                        FOR EACH neighbor v of u (v not in MST):
                            IF w(u,v) < key[v]:
                                key[v] = w(u,v)
                                œÄ[v] = u
                    </div>
                    <p><strong>Why this rule?</strong> Minimum weight edge crossing cut between MST and non-MST vertices is always safe (Cut Property)</p>
                </div>

                <div class="when-to-use">
                    <h4>When to Use Prim's vs Kruskal's:</h4>
                    <ul>
                        <li>Prim's better for <strong>dense graphs</strong> (many edges)</li>
                        <li>Prim's better when using adjacency matrix</li>
                        <li>Similar to Dijkstra's in structure</li>
                    </ul>
                </div>

                <div class="formula-section">
                    <h4>Variables:</h4>
                    <table class="variable-table">
                        <tr>
                            <th>Variable</th>
                            <th>Meaning</th>
                        </tr>
                        <tr>
                            <td>key[v]</td>
                            <td>Minimum weight of edge connecting v to MST</td>
                        </tr>
                        <tr>
                            <td>œÄ[v]</td>
                            <td>Parent of v in MST</td>
                        </tr>
                        <tr>
                            <td>Q</td>
                            <td>Min-priority queue of vertices not yet in MST</td>
                        </tr>
                    </table>
                </div>
            </div>
        </div>

        <!-- GREEDY OPTIMIZATION -->
        <div class="task-category" id="greedy-opt">
            <h2>TASK: Greedy Optimization Problems</h2>
            <p>Problems where local optimal choices lead to global optimum</p>
        </div>

        <div class="subtopic">
            <!-- Activity Selection -->
            <div class="algorithm-card">
                <div class="algorithm-header">
                    <h3>Activity Selection</h3>
                    <p style="margin: 5px 0 0 0; opacity: 0.9;">Maximize number of non-overlapping activities</p>
                </div>

                <div class="complexity-badge">Time: O(n log n)</div>
                <div class="complexity-badge" style="background: #2196f3;">Space: O(1)</div>

                <div class="decision-box">
                    <h4>üéØ Decision Rule (Formulaic):</h4>
                    <div class="formula">
                        SORT activities by finish time: f[1] ‚â§ f[2] ‚â§ ... ‚â§ f[n]

                        CHOOSE: a[1] (earliest finish time)

                        FOR i = 2 to n:
                            CHOOSE a[i] IF s[i] ‚â• f[k]
                                        (start time ‚â• last selected finish time)
                            IF chosen: k = i
                    </div>
                    <p><strong>Why this rule?</strong> Activity with earliest finish time leaves maximum room for remaining activities</p>
                </div>

                <div class="formula-section">
                    <h4>Variables:</h4>
                    <table class="variable-table">
                        <tr>
                            <th>Variable</th>
                            <th>Meaning</th>
                        </tr>
                        <tr>
                            <td>s[i]</td>
                            <td>Start time of activity i</td>
                        </tr>
                        <tr>
                            <td>f[i]</td>
                            <td>Finish time of activity i</td>
                        </tr>
                        <tr>
                            <td>k</td>
                            <td>Index of last selected activity</td>
                        </tr>
                    </table>
                </div>
            </div>

            <!-- Huffman Coding -->
            <div class="algorithm-card">
                <div class="algorithm-header">
                    <h3>Huffman Coding</h3>
                    <p style="margin: 5px 0 0 0; opacity: 0.9;">Optimal prefix-free binary encoding</p>
                </div>

                <div class="complexity-badge">Time: O(n log n)</div>
                <div class="complexity-badge" style="background: #2196f3;">Space: O(n)</div>

                <div class="decision-box">
                    <h4>üéØ Decision Rule (Formulaic):</h4>
                    <div class="formula">
                        WHILE |Q| > 1:
                            CHOOSE: x = extractMin(Q)  (lowest frequency)
                            CHOOSE: y = extractMin(Q)  (second lowest frequency)

                            CREATE: z with freq[z] = freq[x] + freq[y]
                            INSERT: z into Q
                            MAKE: x and y children of z
                    </div>
                    <p><strong>Why this rule?</strong> Merging lowest frequency nodes minimizes total cost Œ£ f[c] ¬∑ depth[c]</p>
                </div>

                <div class="formula-section">
                    <h4>Cost Formula:</h4>
                    <div class="formula">
                        Cost(T) = Œ£ freq[c] ¬∑ depth[c]

                        where:
                        - freq[c] = frequency of character c
                        - depth[c] = depth in tree = code length
                    </div>
                </div>
            </div>
        </div>

        <!-- DYNAMIC PROGRAMMING OPTIMIZATION -->
        <div class="task-category" id="dp-opt">
            <h2>TASK: Dynamic Programming Optimization</h2>
            <p>Problems with overlapping subproblems and optimal substructure</p>
        </div>

        <div class="subtopic">
            <div class="algorithm-card">
                <div class="algorithm-header">
                    <h3>DP General Framework</h3>
                </div>

                <div class="formula-section">
                    <h4>Top-Down vs Bottom-Up:</h4>
                    <table class="variable-table">
                        <tr>
                            <th>Approach</th>
                            <th>Method</th>
                            <th>When to Use</th>
                        </tr>
                        <tr>
                            <td><strong>Top-Down (Memoization)</strong></td>
                            <td>Recursive with cache</td>
                            <td>When not all subproblems needed; easier to write</td>
                        </tr>
                        <tr>
                            <td><strong>Bottom-Up (Tabulation)</strong></td>
                            <td>Iterative table filling</td>
                            <td>When all subproblems needed; better performance</td>
                        </tr>
                    </table>
                </div>
            </div>

            <!-- Rod Cutting -->
            <div class="algorithm-card">
                <div class="algorithm-header">
                    <h3>Rod Cutting</h3>
                    <p style="margin: 5px 0 0 0; opacity: 0.9;">Maximize revenue from cutting rod</p>
                </div>

                <div class="complexity-badge">Time: O(n¬≤)</div>
                <div class="complexity-badge" style="background: #2196f3;">Space: O(n)</div>

                <div class="decision-box">
                    <h4>üéØ Decision Rule (Formulaic):</h4>
                    <div class="formula">
                        For rod of length j:

                        CHOOSE: i* = argmax{p[i] + r[j-i] : i = 1 to j}
                                (cut position that maximizes revenue)

                        r[j] = p[i*] + r[j-i*]
                    </div>
                    <p><strong>Why this rule?</strong> Try all possible first cuts, choose best. Remaining piece solved optimally by subproblem.</p>
                </div>

                <div class="formula-section">
                    <h4>Recurrence Relation:</h4>
                    <div class="formula">
                        r[n] = max{p[i] + r[n-i]} for i = 1 to n

                        Base case: r[0] = 0
                    </div>
                </div>

                <div class="formula-section">
                    <h4>Variables:</h4>
                    <table class="variable-table">
                        <tr>
                            <th>Variable</th>
                            <th>Meaning</th>
                        </tr>
                        <tr>
                            <td>r[i]</td>
                            <td>Maximum revenue for rod of length i</td>
                        </tr>
                        <tr>
                            <td>p[i]</td>
                            <td>Price for rod of length i (no cuts)</td>
                        </tr>
                    </table>
                </div>
            </div>

            <!-- Matrix Chain Multiplication -->
            <div class="algorithm-card">
                <div class="algorithm-header">
                    <h3>Matrix Chain Multiplication</h3>
                    <p style="margin: 5px 0 0 0; opacity: 0.9;">Minimize scalar multiplications</p>
                </div>

                <div class="complexity-badge">Time: O(n¬≥)</div>
                <div class="complexity-badge" style="background: #2196f3;">Space: O(n¬≤)</div>

                <div class="decision-box">
                    <h4>üéØ Decision Rule (Formulaic):</h4>
                    <div class="formula">
                        For multiplying A[i..j]:

                        CHOOSE: k* = argmin{m[i,k] + m[k+1,j] + p[i-1]¬∑p[k]¬∑p[j]
                                           : k = i to j-1}
                                (split position minimizing total cost)

                        m[i,j] = m[i,k*] + m[k*+1,j] + p[i-1]¬∑p[k*]¬∑p[j]
                    </div>
                    <p><strong>Why this rule?</strong> Try all possible split points, choose minimum cost. Parenthesization matters!</p>
                </div>

                <div class="formula-section">
                    <h4>Recurrence Relation:</h4>
                    <div class="formula">
                        m[i,j] = min{m[i,k] + m[k+1,j] + p[i-1]¬∑p[k]¬∑p[j]}
                                 for k = i to j-1

                        Base case: m[i,i] = 0 (single matrix)
                    </div>
                </div>

                <div class="formula-section">
                    <h4>Variables:</h4>
                    <table class="variable-table">
                        <tr>
                            <th>Variable</th>
                            <th>Meaning</th>
                        </tr>
                        <tr>
                            <td>m[i,j]</td>
                            <td>Min scalar multiplications for A[i..j]</td>
                        </tr>
                        <tr>
                            <td>p[i]</td>
                            <td>Dimensions: A[i] is p[i-1] √ó p[i]</td>
                        </tr>
                        <tr>
                            <td>s[i,j]</td>
                            <td>Optimal split index k for A[i..j]</td>
                        </tr>
                    </table>
                </div>
            </div>

            <!-- LCS -->
            <div class="algorithm-card">
                <div class="algorithm-header">
                    <h3>Longest Common Subsequence (LCS)</h3>
                    <p style="margin: 5px 0 0 0; opacity: 0.9;">Find longest subsequence common to two sequences</p>
                </div>

                <div class="complexity-badge">Time: O(mn)</div>
                <div class="complexity-badge" style="background: #2196f3;">Space: O(mn)</div>

                <div class="decision-box">
                    <h4>üéØ Decision Rule (Formulaic):</h4>
                    <div class="formula">
                        IF X[i] = Y[j]:
                            CHOOSE: Include X[i] in LCS
                            LCS[i,j] = LCS[i-1,j-1] + 1

                        ELSE:
                            CHOOSE: max(LCS[i-1,j], LCS[i,j-1])
                                   (best of excluding X[i] or Y[j])
                    </div>
                    <p><strong>Why this rule?</strong> If characters match, must include. If not, one must be excluded - try both, take best.</p>
                </div>

                <div class="formula-section">
                    <h4>Recurrence Relation:</h4>
                    <div class="formula">
                        LCS[i,j] = {
                            0                              if i=0 or j=0
                            LCS[i-1,j-1] + 1              if X[i] = Y[j]
                            max(LCS[i-1,j], LCS[i,j-1])   if X[i] ‚â† Y[j]
                        }
                    </div>
                </div>

                <div class="formula-section">
                    <h4>Variables:</h4>
                    <table class="variable-table">
                        <tr>
                            <th>Variable</th>
                            <th>Meaning</th>
                        </tr>
                        <tr>
                            <td>LCS[i,j]</td>
                            <td>Length of LCS of X[1..i] and Y[1..j]</td>
                        </tr>
                        <tr>
                            <td>m</td>
                            <td>Length of sequence X</td>
                        </tr>
                        <tr>
                            <td>n</td>
                            <td>Length of sequence Y</td>
                        </tr>
                    </table>
                </div>
            </div>
        </div>

        <!-- NETWORK FLOW -->
        <div class="task-category" id="flow">
            <h2>TASK: Network Flow Problems</h2>
            <p>Maximizing flow through a network with capacity constraints</p>
        </div>

        <div class="subtopic">
            <!-- Ford-Fulkerson -->
            <div class="algorithm-card">
                <div class="algorithm-header">
                    <h3>Ford-Fulkerson Method</h3>
                    <p style="margin: 5px 0 0 0; opacity: 0.9;">Iteratively find augmenting paths</p>
                </div>

                <div class="complexity-badge">Time: O(E¬∑|f*|)</div>
                <div class="complexity-badge" style="background: #2196f3;">Space: O(V+E)</div>

                <div class="decision-box">
                    <h4>üéØ Decision Rule (Formulaic):</h4>
                    <div class="formula">
                        WHILE exists path p from s to t in residual graph G_f:
                            CHOOSE: Any augmenting path p

                            COMPUTE: c_f(p) = min{c_f(u,v) : (u,v) on p}
                                     (bottleneck capacity)

                            FOR EACH edge (u,v) on p:
                                IF forward edge: f(u,v) += c_f(p)
                                IF backward edge: f(v,u) -= c_f(p)
                    </div>
                    <p><strong>Why this rule?</strong> Augmenting path always improves flow. Stop when no path exists ‚Üí max flow reached.</p>
                </div>

                <div class="formula-section">
                    <h4>Residual Capacity Formula:</h4>
                    <div class="formula">
                        c_f(u,v) = {
                            c(u,v) - f(u,v)  if (u,v) ‚àà E (forward)
                            f(v,u)           if (v,u) ‚àà E (backward)
                            0                otherwise
                        }
                    </div>
                </div>

                <div class="formula-section">
                    <h4>Max-Flow Min-Cut Theorem:</h4>
                    <div class="formula">
                        Maximum flow value = Minimum cut capacity
                    </div>
                </div>
            </div>

            <!-- Edmonds-Karp -->
            <div class="algorithm-card">
                <div class="algorithm-header">
                    <h3>Edmonds-Karp Algorithm</h3>
                    <p style="margin: 5px 0 0 0; opacity: 0.9;">Ford-Fulkerson with BFS for paths</p>
                </div>

                <div class="complexity-badge">Time: O(VE¬≤)</div>
                <div class="complexity-badge" style="background: #2196f3;">Space: O(V+E)</div>

                <div class="decision-box">
                    <h4>üéØ Decision Rule (Formulaic):</h4>
                    <div class="formula">
                        CHOOSE: Shortest augmenting path p in residual graph
                                (shortest = fewest edges, use BFS)

                        [Then same augmentation as Ford-Fulkerson]
                    </div>
                    <p><strong>Why this rule?</strong> BFS guarantees shortest path ‚Üí ensures polynomial time O(VE¬≤), not pseudo-polynomial</p>
                </div>
            </div>

            <!-- Bipartite Matching -->
            <div class="algorithm-card">
                <div class="algorithm-header">
                    <h3>Maximum Bipartite Matching</h3>
                    <p style="margin: 5px 0 0 0; opacity: 0.9;">Reduce to max flow problem</p>
                </div>

                <div class="complexity-badge">Time: O(VE¬≤)</div>
                <div class="complexity-badge" style="background: #2196f3;">Space: O(V+E)</div>

                <div class="decision-box">
                    <h4>üéØ Reduction to Max Flow:</h4>
                    <div class="formula">
                        Given bipartite graph G = (L ‚à™ R, E):

                        1. Add source s with edges to all v ‚àà L (capacity 1)
                        2. Add sink t with edges from all v ‚àà R (capacity 1)
                        3. Direct all edges from L to R (capacity 1)
                        4. Run max flow algorithm

                        Maximum matching = Maximum flow value
                    </div>
                </div>
            </div>
        </div>

        <!-- DIVIDE AND CONQUER -->
        <div class="task-category" id="divide-conquer">
            <h2>TASK: Divide and Conquer</h2>
            <p>Breaking problems into subproblems, solving recursively, and combining results</p>
        </div>

        <div class="subtopic">
            <!-- Master Theorem -->
            <div class="algorithm-card">
                <div class="algorithm-header">
                    <h3>Master Theorem</h3>
                    <p style="margin: 5px 0 0 0; opacity: 0.9;">For analyzing divide-and-conquer recurrences</p>
                </div>

                <div class="formula-section">
                    <h4>General Form:</h4>
                    <div class="formula">
                        T(n) = aT(n/b) + f(n)

                        where:
                        - a ‚â• 1 (number of subproblems)
                        - b > 1 (subproblem size reduction factor)
                        - f(n) = cost of divide + combine
                    </div>
                </div>

                <div class="decision-box">
                    <h4>üéØ Decision Rule - Which Case?</h4>
                    <div class="formula">
                        COMPARE: f(n) with n^(log_b a)

                        CASE 1: f(n) = O(n^(log_b a - Œµ)) for Œµ > 0
                               [f grows polynomially SLOWER]
                               ‚Üí T(n) = Œò(n^(log_b a))

                        CASE 2: f(n) = Œò(n^(log_b a) ¬∑ log^k n), k ‚â• 0
                               [f grows at SAME rate]
                               ‚Üí T(n) = Œò(n^(log_b a) ¬∑ log^(k+1) n)

                        CASE 3: f(n) = Œ©(n^(log_b a + Œµ)) for Œµ > 0
                               AND af(n/b) ‚â§ cf(n) for c < 1
                               [f grows polynomially FASTER]
                               ‚Üí T(n) = Œò(f(n))
                    </div>
                </div>

                <div class="formula-section">
                    <h4>Common Examples:</h4>
                    <table class="variable-table">
                        <tr>
                            <th>Recurrence</th>
                            <th>a</th>
                            <th>b</th>
                            <th>n^(log_b a)</th>
                            <th>Case</th>
                            <th>Solution</th>
                        </tr>
                        <tr>
                            <td>T(n) = 2T(n/2) + n</td>
                            <td>2</td>
                            <td>2</td>
                            <td>n</td>
                            <td>2 (k=0)</td>
                            <td>Œò(n log n)</td>
                        </tr>
                        <tr>
                            <td>T(n) = 4T(n/2) + n</td>
                            <td>4</td>
                            <td>2</td>
                            <td>n¬≤</td>
                            <td>1</td>
                            <td>Œò(n¬≤)</td>
                        </tr>
                        <tr>
                            <td>T(n) = T(n/2) + 1</td>
                            <td>1</td>
                            <td>2</td>
                            <td>1</td>
                            <td>2 (k=0)</td>
                            <td>Œò(log n)</td>
                        </tr>
                        <tr>
                            <td>T(n) = 7T(n/2) + n¬≤</td>
                            <td>7</td>
                            <td>2</td>
                            <td>n^2.81</td>
                            <td>1</td>
                            <td>Œò(n^2.81)</td>
                        </tr>
                    </table>
                </div>
            </div>

            <!-- Strassen's -->
            <div class="algorithm-card">
                <div class="algorithm-header">
                    <h3>Strassen's Matrix Multiplication</h3>
                    <p style="margin: 5px 0 0 0; opacity: 0.9;">Faster matrix multiplication using divide-and-conquer</p>
                </div>

                <div class="complexity-badge">Time: O(n^2.81)</div>
                <div class="complexity-badge" style="background: #2196f3;">Space: O(n¬≤)</div>

                <div class="formula-section">
                    <h4>Divide, Conquer, Combine:</h4>
                    <div class="formula">
                        DIVIDE: Partition n√ón matrices into (n/2)√ó(n/2) blocks

                        A = [A11  A12]    B = [B11  B12]
                            [A21  A22]        [B21  B22]

                        CONQUER: Compute 7 products (not 8!):

                        P1 = A11(B12 - B22)
                        P2 = (A11 + A12)B22
                        P3 = (A21 + A22)B11
                        P4 = A22(B21 - B11)
                        P5 = (A11 + A22)(B11 + B22)
                        P6 = (A12 - A22)(B21 + B22)
                        P7 = (A11 - A21)(B11 + B12)

                        COMBINE: Compute result blocks

                        C11 = P5 + P4 - P2 + P6
                        C12 = P1 + P2
                        C21 = P3 + P4
                        C22 = P5 + P1 - P3 - P7
                    </div>
                </div>

                <div class="formula-section">
                    <h4>Recurrence Analysis:</h4>
                    <div class="formula">
                        T(n) = 7T(n/2) + Œò(n¬≤)

                        Master Theorem Case 1:
                        n^(log_2 7) ‚âà n^2.81 > n¬≤

                        Therefore: T(n) = Œò(n^2.81)

                        [Better than naive Œò(n¬≥)]
                    </div>
                </div>
            </div>
        </div>

        <!-- Quick Reference Summary -->
        <div class="subtopic">
            <h2>Quick Reference: All Complexities by Task</h2>
            <table class="complexity-table">
                <thead>
                    <tr>
                        <th>Task</th>
                        <th>Algorithm</th>
                        <th>Time</th>
                        <th>Space</th>
                        <th>Key Decision Rule</th>
                    </tr>
                </thead>
                <tbody>
                    <tr style="background: #e3f2fd;">
                        <td rowspan="2"><strong>Shortest Path</strong></td>
                        <td>BFS</td>
                        <td>O(V+E)</td>
                        <td>O(V)</td>
                        <td>FIFO queue ‚Üí level-by-level</td>
                    </tr>
                    <tr style="background: #e3f2fd;">
                        <td>Dijkstra's</td>
                        <td>O((V+E) log V)</td>
                        <td>O(V)</td>
                        <td>Min distance vertex + relax</td>
                    </tr>
                    <tr>
                        <td rowspan="3"><strong>Traversal/Ordering</strong></td>
                        <td>DFS</td>
                        <td>O(V+E)</td>
                        <td>O(V)</td>
                        <td>LIFO stack ‚Üí depth-first</td>
                    </tr>
                    <tr>
                        <td>Topological Sort</td>
                        <td>O(V+E)</td>
                        <td>O(V)</td>
                        <td>DFS finish times (reverse)</td>
                    </tr>
                    <tr>
                        <td>SCC (Kosaraju)</td>
                        <td>O(V+E)</td>
                        <td>O(V)</td>
                        <td>2 DFS: G then G^T</td>
                    </tr>
                    <tr style="background: #f1f8e9;">
                        <td rowspan="2"><strong>MST</strong></td>
                        <td>Kruskal's</td>
                        <td>O(E log E)</td>
                        <td>O(V)</td>
                        <td>Min edge without cycle</td>
                    </tr>
                    <tr style="background: #f1f8e9;">
                        <td>Prim's</td>
                        <td>O((V+E) log V)</td>
                        <td>O(V)</td>
                        <td>Min edge to new vertex</td>
                    </tr>
                    <tr>
                        <td rowspan="2"><strong>Greedy Opt</strong></td>
                        <td>Activity Selection</td>
                        <td>O(n log n)</td>
                        <td>O(1)</td>
                        <td>Earliest finish time</td>
                    </tr>
                    <tr>
                        <td>Huffman</td>
                        <td>O(n log n)</td>
                        <td>O(n)</td>
                        <td>Merge two min frequencies</td>
                    </tr>
                    <tr style="background: #fce4ec;">
                        <td rowspan="3"><strong>DP Opt</strong></td>
                        <td>Rod Cutting</td>
                        <td>O(n¬≤)</td>
                        <td>O(n)</td>
                        <td>max over all first cuts</td>
                    </tr>
                    <tr style="background: #fce4ec;">
                        <td>Matrix Chain</td>
                        <td>O(n¬≥)</td>
                        <td>O(n¬≤)</td>
                        <td>min over all split points</td>
                    </tr>
                    <tr style="background: #fce4ec;">
                        <td>LCS</td>
                        <td>O(mn)</td>
                        <td>O(mn)</td>
                        <td>Match? +1 : max of exclude</td>
                    </tr>
                    <tr>
                        <td rowspan="2"><strong>Flow</strong></td>
                        <td>Ford-Fulkerson</td>
                        <td>O(E¬∑|f*|)</td>
                        <td>O(V+E)</td>
                        <td>Any augmenting path</td>
                    </tr>
                    <tr>
                        <td>Edmonds-Karp</td>
                        <td>O(VE¬≤)</td>
                        <td>O(V+E)</td>
                        <td>Shortest augmenting path (BFS)</td>
                    </tr>
                    <tr style="background: #fff9c4;">
                        <td rowspan="2"><strong>Divide & Conquer</strong></td>
                        <td>Master Theorem</td>
                        <td>-</td>
                        <td>-</td>
                        <td>Compare f(n) vs n^(log_b a)</td>
                    </tr>
                    <tr style="background: #fff9c4;">
                        <td>Strassen's</td>
                        <td>O(n^2.81)</td>
                        <td>O(n¬≤)</td>
                        <td>7 subproblems instead of 8</td>
                    </tr>
                </tbody>
            </table>
        </div>
    </div>

    <!-- Footer -->
    <footer>
        <p>Good luck on your final exam! üöÄ</p>
        <p style="font-size: 0.9em; margin-top: 10px;">Platform generated with Claude Code</p>
    </footer>

    <script src="scripts.js"></script>
</body>
</html>
