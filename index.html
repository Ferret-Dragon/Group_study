<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DSA Final Exam - Study Platform</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #e3f2fd 0%, #e1f5fe 50%, #e0f7fa 100%);
            color: #2d2d2d;
            line-height: 1.6;
            padding: 20px;
            min-height: 100vh;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
        }

        header {
            background: linear-gradient(135deg, #64b5f6 0%, #42a5f5 100%);
            padding: 30px;
            margin-bottom: 30px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
        }

        h1 {
            color: #fff;
            font-size: 2.5em;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.2);
        }

        .subtitle {
            color: #f0f0f0;
            font-size: 1.2em;
        }

        .timer {
            background: #b3e5fc;
            padding: 20px;
            margin-bottom: 20px;
            text-align: center;
            font-size: 1.3em;
            font-weight: bold;
            color: #0d47a1;
            box-shadow: 0 3px 10px rgba(0, 0, 0, 0.1);
        }

        .main-grid {
            display: grid;
            grid-template-columns: 300px 1fr;
            gap: 20px;
            margin-bottom: 30px;
        }

        .sidebar {
            background: #e1f5fe;
            padding: 25px;
            box-shadow: 0 3px 10px rgba(0, 0, 0, 0.1);
            height: fit-content;
            position: sticky;
            top: 20px;
        }

        .sidebar h2 {
            color: #0d47a1;
            margin-bottom: 15px;
            font-size: 1.5em;
        }

        .progress-container {
            background: #bbdefb;
            padding: 15px;
            margin-bottom: 20px;
        }

        .progress-bar {
            background: #fff;
            height: 30px;
            margin-top: 10px;
            overflow: hidden;
            position: relative;
        }

        .progress-fill {
            background: linear-gradient(90deg, #42a5f5 0%, #1e88e5 100%);
            height: 100%;
            width: 0%;
            transition: width 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #fff;
            font-weight: bold;
        }

        .schedule-item {
            background: #fff;
            padding: 12px;
            margin-bottom: 10px;
            border-left: 4px solid #42a5f5;
        }

        .schedule-item.completed {
            opacity: 0.6;
            background: #f0f0f0;
        }

        .schedule-time {
            font-weight: bold;
            color: #0d47a1;
        }

        .main-content {
            background: #fff;
            padding: 30px;
            box-shadow: 0 3px 10px rgba(0, 0, 0, 0.1);
        }

        .topic-section {
            margin-bottom: 35px;
            border-left: 6px solid #42a5f5;
            padding-left: 25px;
        }

        .topic-section h2 {
            color: #0d47a1;
            font-size: 2em;
            margin-bottom: 15px;
            cursor: pointer;
            user-select: none;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .topic-section h2:hover {
            color: #1976d2;
        }

        .toggle-icon {
            font-size: 0.7em;
            transition: transform 0.3s;
        }

        .toggle-icon.collapsed {
            transform: rotate(-90deg);
        }

        .topic-content {
            max-height: 5000px;
            overflow: hidden;
            transition: max-height 0.3s ease;
        }

        .topic-content.collapsed {
            max-height: 0;
        }

        .subtopic {
            background: #f1f8fe;
            padding: 20px;
            margin: 15px 0;
            border-left: 3px solid #90caf9;
        }

        .subtopic h3 {
            color: #1565c0;
            margin-bottom: 12px;
            font-size: 1.4em;
        }

        .key-concepts {
            background: #e6f7ff;
            padding: 15px;
            margin: 15px 0;
        }

        .key-concepts h4 {
            color: #4a7ba7;
            margin-bottom: 10px;
        }

        .key-concepts ul {
            margin-left: 20px;
        }

        .key-concepts li {
            margin: 8px 0;
        }

        .video-recommendations {
            background: #fff4e6;
            padding: 15px;
            margin: 15px 0;
        }

        .video-recommendations h4 {
            color: #d97706;
            margin-bottom: 10px;
        }

        .video-link {
            display: block;
            color: #2563eb;
            text-decoration: none;
            margin: 8px 0;
            padding: 8px;
            background: #fff;
            transition: background 0.2s;
        }

        .video-link:hover {
            background: #fffbeb;
            text-decoration: underline;
        }

        .practice-tip {
            background: #d1fae5;
            padding: 15px;
            margin: 15px 0;
            border-left: 3px solid #10b981;
        }

        .practice-tip h4 {
            color: #065f46;
            margin-bottom: 8px;
        }

        .warning-box {
            background: #ffe6e6;
            padding: 15px;
            margin: 15px 0;
            border-left: 3px solid #ef4444;
        }

        .warning-box h4 {
            color: #991b1b;
            margin-bottom: 8px;
        }

        .checklist {
            list-style: none;
            margin-left: 0;
        }

        .checklist li {
            margin: 10px 0;
            padding: 8px;
            background: #fafafa;
            cursor: pointer;
            transition: background 0.2s;
        }

        .checklist li:hover {
            background: #f0f0f0;
        }

        .checklist input[type="checkbox"] {
            margin-right: 10px;
            transform: scale(1.3);
            cursor: pointer;
        }

        .checklist li.checked {
            opacity: 0.6;
            text-decoration: line-through;
        }

        .quick-reference {
            background: #fef3c7;
            padding: 20px;
            margin: 20px 0;
        }

        .quick-reference h3 {
            color: #92400e;
            margin-bottom: 15px;
        }

        .complexity-table {
            width: 100%;
            border-collapse: collapse;
            margin: 15px 0;
            background: #fff;
        }

        .complexity-table th,
        .complexity-table td {
            padding: 12px;
            text-align: left;
            border: 1px solid #ddd;
        }

        .complexity-table th {
            background: #42a5f5;
            color: #fff;
        }

        .complexity-table tr:nth-child(even) {
            background: #f9f9f9;
        }

        .time-block {
            background: #b3e5fc;
            padding: 15px;
            margin: 10px 0;
            font-weight: bold;
        }

        .study-tips {
            background: #fce7f3;
            padding: 20px;
            margin-bottom: 20px;
        }

        .study-tips h3 {
            color: #831843;
            margin-bottom: 12px;
        }

        .study-tips ul {
            margin-left: 20px;
        }

        .study-tips li {
            margin: 8px 0;
        }

        code {
            background: #f4f4f4;
            padding: 2px 6px;
            font-family: 'Courier New', monospace;
            color: #c7254e;
        }

        .formula {
            background: #f0f9ff;
            padding: 10px 15px;
            margin: 10px 0;
            font-family: 'Courier New', monospace;
            border-left: 3px solid #0284c7;
        }

        button {
            background: #42a5f5;
            color: #fff;
            border: none;
            padding: 12px 24px;
            font-size: 1em;
            cursor: pointer;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.2);
            transition: background 0.2s;
        }

        button:hover {
            background: #1976d2;
        }

        @media (max-width: 1024px) {
            .main-grid {
                grid-template-columns: 1fr;
            }

            .sidebar {
                position: relative;
                top: 0;
            }
        }

        .resources-section {
            background: #f0fdf4;
            padding: 20px;
            margin: 20px 0;
        }

        .resources-section h3 {
            color: #14532d;
            margin-bottom: 15px;
        }

        .visual-section {
            background: #fff;
            padding: 20px;
            margin: 20px 0;
            border: 2px solid #42a5f5;
        }

        .visual-section h4 {
            color: #0d47a1;
            margin-bottom: 15px;
        }

        .graph-container {
            text-align: center;
            margin: 20px 0;
            padding: 20px;
            background: #f8f9fa;
        }

        .quiz-box {
            background: #fff9c4;
            padding: 20px;
            margin: 20px 0;
            border-left: 4px solid #fbc02d;
        }

        .quiz-box h4 {
            color: #f57f17;
            margin-bottom: 15px;
        }

        .quiz-question {
            margin: 15px 0;
            padding: 15px;
            background: #fff;
        }

        .quiz-options {
            margin: 10px 0;
        }

        .quiz-option {
            padding: 10px;
            margin: 8px 0;
            background: #f5f5f5;
            cursor: pointer;
            transition: background 0.2s;
            border-left: 3px solid transparent;
        }

        .quiz-option:hover {
            background: #e0e0e0;
        }

        .quiz-option.selected {
            background: #e3f2fd;
            border-left-color: #42a5f5;
        }

        .quiz-option.correct {
            background: #c8e6c9;
            border-left-color: #4caf50;
        }

        .quiz-option.incorrect {
            background: #ffcdd2;
            border-left-color: #f44336;
        }

        .quiz-explanation {
            display: none;
            margin-top: 10px;
            padding: 15px;
            background: #e8f5e9;
            border-left: 3px solid #4caf50;
        }

        .quiz-explanation.show {
            display: block;
        }

        .self-check {
            background: #f3e5f5;
            padding: 20px;
            margin: 20px 0;
            border-left: 4px solid #9c27b0;
        }

        .self-check h4 {
            color: #6a1b9a;
            margin-bottom: 15px;
        }

        .trace-exercise {
            background: #fce4ec;
            padding: 20px;
            margin: 20px 0;
            border-left: 4px solid #e91e63;
        }

        .trace-exercise h4 {
            color: #880e4f;
            margin-bottom: 15px;
        }

        .trace-step {
            background: #fff;
            padding: 15px;
            margin: 10px 0;
            border: 1px solid #ddd;
        }

        .trace-step-header {
            font-weight: bold;
            color: #0d47a1;
            margin-bottom: 8px;
        }

        .interactive-graph {
            margin: 20px 0;
            padding: 20px;
            background: #fff;
            border: 2px solid #42a5f5;
        }

        .graph-legend {
            display: flex;
            gap: 20px;
            margin: 15px 0;
            flex-wrap: wrap;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .legend-color {
            width: 20px;
            height: 20px;
            border: 1px solid #333;
        }

        .complexity-chart {
            margin: 20px 0;
            padding: 20px;
            background: #f8f9fa;
        }

        .show-answer-btn {
            background: #66bb6a;
            color: #fff;
            border: none;
            padding: 8px 16px;
            cursor: pointer;
            margin-top: 10px;
            transition: background 0.2s;
        }

        .show-answer-btn:hover {
            background: #4caf50;
        }

        .hidden-answer {
            display: none;
            margin-top: 15px;
            padding: 15px;
            background: #e8f5e9;
            border-left: 3px solid #4caf50;
        }

        .hidden-answer.revealed {
            display: block;
        }

        svg text {
            font-family: 'Segoe UI', sans-serif;
            font-size: 14px;
        }

        .comparison-table {
            width: 100%;
            margin: 20px 0;
            border-collapse: collapse;
        }

        .comparison-table th,
        .comparison-table td {
            padding: 12px;
            border: 1px solid #ddd;
            text-align: left;
        }

        .comparison-table th {
            background: #42a5f5;
            color: #fff;
        }

        .comparison-table tr:nth-child(even) {
            background: #f9f9f9;
        }

        .highlight-box {
            background: #fff3cd;
            padding: 15px;
            margin: 15px 0;
            border-left: 4px solid #ffc107;
        }

        .highlight-box h5 {
            color: #f57f17;
            margin-bottom: 8px;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>DSA Cumulative Final - Study Platform</h1>
            <p class="subtitle">Master Algorithms & Data Structures in One Intensive Session</p>
        </header>

        <div class="timer">
            <div id="countdown">Time until exam: Loading...</div>
        </div>

        <div class="study-tips">
            <h3>Study Strategy for Success</h3>
            <ul>
                <li><strong>Active Recall:</strong> Don't just read - try to explain algorithms out loud</li>
                <li><strong>Practice Problems:</strong> Work through your problem sets (ps1-ps8) - especially ones you struggled with</li>
                <li><strong>Visualize:</strong> Draw out graphs, trees, and algorithm steps</li>
                <li><strong>Break Time:</strong> Take 5-10 min breaks every hour to stay sharp</li>
                <li><strong>Focus on Understanding:</strong> Why algorithms work matters more than memorizing steps</li>
                <li><strong>Common Patterns:</strong> Notice similarities (DFS used in topological sort & SCC, greedy in MST & Dijkstra)</li>
            </ul>
        </div>

        <div class="main-grid">
            <aside class="sidebar">
                <h2>Study Schedule</h2>
                <div class="progress-container">
                    <div>Overall Progress</div>
                    <div class="progress-bar">
                        <div class="progress-fill" id="progressBar">0%</div>
                    </div>
                </div>

                <div class="time-block">AFTERNOON SESSION (4-5 hours)</div>

                <div class="schedule-item" data-topic="graphs">
                    <div class="schedule-time">Hour 1-2:</div>
                    <div>Graphs Deep Dive</div>
                </div>

                <div class="schedule-item" data-topic="divide-conquer">
                    <div class="schedule-time">Hour 2-3:</div>
                    <div>Divide & Conquer</div>
                </div>

                <div class="schedule-item" data-topic="greedy">
                    <div class="schedule-time">Hour 3-4:</div>
                    <div>Greedy Algorithms</div>
                </div>

                <div class="schedule-item" data-topic="dynamic">
                    <div class="schedule-time">Hour 4-5:</div>
                    <div>Dynamic Programming</div>
                </div>

                <div class="time-block">EVENING: Rest & Review Problem Sets</div>

                <div class="time-block">MORNING SESSION (3-4 hours)</div>

                <div class="schedule-item" data-topic="maxflow">
                    <div class="schedule-time">Hour 1-1.5:</div>
                    <div>Maximum Flow</div>
                </div>

                <div class="schedule-item" data-topic="review">
                    <div class="schedule-time">Hour 1.5-2.5:</div>
                    <div>Practice Problems Review</div>
                </div>

                <div class="schedule-item" data-topic="final-review">
                    <div class="schedule-time">Hour 2.5-3:</div>
                    <div>Quick Reference Review</div>
                </div>

                <button onclick="resetProgress()">Reset Progress</button>
            </aside>

            <main class="main-content">
                <!-- GRAPHS SECTION -->
                <div class="topic-section" id="graphs">
                    <h2 onclick="toggleSection('graphs')">
                        <span class="toggle-icon">‚ñº</span>
                        1. Graphs (Most Important!)
                    </h2>
                    <div class="topic-content">
                        <div class="subtopic">
                            <h3>Graph Representations</h3>
                            <div class="key-concepts">
                                <h4>Key Concepts:</h4>
                                <ul>
                                    <li><strong>Adjacency Matrix:</strong> 2D array, O(1) edge lookup, O(V¬≤) space</li>
                                    <li><strong>Adjacency List:</strong> Array of lists, O(V+E) space, better for sparse graphs</li>
                                    <li><strong>When to use which:</strong> Matrix for dense graphs, lists for sparse</li>
                                </ul>
                            </div>
                            <div class="practice-tip">
                                <h4>Practice Tip:</h4>
                                <p>Draw a simple graph and convert it between both representations. This is a common exam question!</p>
                            </div>
                        </div>

                        <div class="subtopic">
                            <h3>Breadth-First Search (BFS)</h3>
                            <div class="key-concepts">
                                <h4>Key Concepts:</h4>
                                <ul>
                                    <li><strong>Uses Queue (FIFO)</strong> - explores level by level</li>
                                    <li><strong>Time Complexity:</strong> O(V + E) with adjacency list</li>
                                    <li><strong>Space Complexity:</strong> O(V) for queue and visited array</li>
                                    <li><strong>Applications:</strong> Shortest path in unweighted graphs, level-order traversal</li>
                                    <li><strong>Output:</strong> BFS tree, distances from source</li>
                                </ul>
                            </div>
                            <div class="video-recommendations">
                                <h4>Video Recommendations:</h4>
                                <a href="https://www.youtube.com/watch?v=oDqjPvD54Ss" target="_blank" class="video-link">üé• Abdul Bari - BFS Graph Traversal (17 min)</a>
                                <a href="https://www.youtube.com/watch?v=hettiSrJjM4" target="_blank" class="video-link">üé• William Fiset - BFS Shortest Path (13 min)</a>
                            </div>
                            <div class="practice-tip">
                                <h4>Walkthrough:</h4>
                                <ol>
                                    <li>Initialize: Mark source as visited, enqueue source</li>
                                    <li>While queue not empty: dequeue vertex u</li>
                                    <li>For each neighbor v of u: if not visited, mark visited, enqueue v, set distance[v] = distance[u] + 1</li>
                                    <li>Result: All reachable vertices visited, shortest paths computed</li>
                                </ol>
                            </div>

                            <div class="visual-section">
                                <h4>üìä Visual Example: BFS Traversal</h4>
                                <div class="graph-container">
                                    <svg width="600" height="300" viewBox="0 0 600 300">
                                        <!-- Graph edges -->
                                        <line x1="100" y1="50" x2="200" y2="100" stroke="#90caf9" stroke-width="2"/>
                                        <line x1="100" y1="50" x2="200" y2="150" stroke="#90caf9" stroke-width="2"/>
                                        <line x1="200" y1="100" x2="350" y2="75" stroke="#90caf9" stroke-width="2"/>
                                        <line x1="200" y1="100" x2="350" y2="125" stroke="#90caf9" stroke-width="2"/>
                                        <line x1="200" y1="150" x2="350" y2="175" stroke="#90caf9" stroke-width="2"/>
                                        <line x1="200" y1="150" x2="350" y2="225" stroke="#90caf9" stroke-width="2"/>
                                        <line x1="350" y1="125" x2="500" y2="150" stroke="#90caf9" stroke-width="2"/>

                                        <!-- Nodes -->
                                        <circle cx="100" cy="50" r="25" fill="#42a5f5" stroke="#0d47a1" stroke-width="2"/>
                                        <text x="100" y="55" text-anchor="middle" fill="white" font-weight="bold">A</text>
                                        <text x="100" y="95" text-anchor="middle" fill="#0d47a1" font-size="12">Level 0</text>

                                        <circle cx="200" cy="100" r="25" fill="#64b5f6" stroke="#0d47a1" stroke-width="2"/>
                                        <text x="200" y="105" text-anchor="middle" fill="white" font-weight="bold">B</text>
                                        <text x="200" y="140" text-anchor="middle" fill="#0d47a1" font-size="12">Level 1</text>

                                        <circle cx="200" cy="150" r="25" fill="#64b5f6" stroke="#0d47a1" stroke-width="2"/>
                                        <text x="200" y="155" text-anchor="middle" fill="white" font-weight="bold">C</text>
                                        <text x="200" y="190" text-anchor="middle" fill="#0d47a1" font-size="12">Level 1</text>

                                        <circle cx="350" cy="75" r="25" fill="#90caf9" stroke="#0d47a1" stroke-width="2"/>
                                        <text x="350" y="80" text-anchor="middle" fill="white" font-weight="bold">D</text>

                                        <circle cx="350" cy="125" r="25" fill="#90caf9" stroke="#0d47a1" stroke-width="2"/>
                                        <text x="350" y="130" text-anchor="middle" fill="white" font-weight="bold">E</text>

                                        <circle cx="350" cy="175" r="25" fill="#90caf9" stroke="#0d47a1" stroke-width="2"/>
                                        <text x="350" y="180" text-anchor="middle" fill="white" font-weight="bold">F</text>

                                        <circle cx="350" cy="225" r="25" fill="#90caf9" stroke="#0d47a1" stroke-width="2"/>
                                        <text x="350" y="230" text-anchor="middle" fill="white" font-weight="bold">G</text>

                                        <circle cx="500" cy="150" r="25" fill="#bbdefb" stroke="#0d47a1" stroke-width="2"/>
                                        <text x="500" y="155" text-anchor="middle" fill="white" font-weight="bold">H</text>

                                        <text x="380" y="25" text-anchor="start" fill="#0d47a1" font-size="12">Level 2: D, E, F, G</text>
                                        <text x="520" y="150" text-anchor="start" fill="#0d47a1" font-size="12">Level 3: H</text>
                                    </svg>
                                </div>
                                <div class="graph-legend">
                                    <div class="legend-item">
                                        <div class="legend-color" style="background: #42a5f5;"></div>
                                        <span>Starting node (Level 0)</span>
                                    </div>
                                    <div class="legend-item">
                                        <div class="legend-color" style="background: #64b5f6;"></div>
                                        <span>Level 1</span>
                                    </div>
                                    <div class="legend-item">
                                        <div class="legend-color" style="background: #90caf9;"></div>
                                        <span>Level 2</span>
                                    </div>
                                    <div class="legend-item">
                                        <div class="legend-color" style="background: #bbdefb;"></div>
                                        <span>Level 3</span>
                                    </div>
                                </div>
                                <p><strong>BFS Order from A:</strong> A ‚Üí B ‚Üí C ‚Üí D ‚Üí E ‚Üí F ‚Üí G ‚Üí H</p>
                                <p><strong>Queue progression:</strong> [A] ‚Üí [B,C] ‚Üí [C,D,E] ‚Üí [D,E,F,G] ‚Üí [E,F,G] ‚Üí [F,G,H] ‚Üí [G,H] ‚Üí [H] ‚Üí []</p>
                            </div>

                            <div class="trace-exercise">
                                <h4>‚úèÔ∏è Trace Exercise: Practice BFS</h4>
                                <p><strong>Try this yourself:</strong> Given the graph above, what would be the BFS traversal starting from node C?</p>
                                <button class="show-answer-btn" onclick="toggleAnswer('bfs-trace-1')">Show Answer</button>
                                <div class="hidden-answer" id="bfs-trace-1">
                                    <p><strong>Answer:</strong> C ‚Üí B ‚Üí A ‚Üí F ‚Üí G ‚Üí D ‚Üí E ‚Üí H</p>
                                    <p><strong>Explanation:</strong></p>
                                    <ul>
                                        <li>Level 0: C (start)</li>
                                        <li>Level 1: B, F, G (neighbors of C)</li>
                                        <li>Level 2: A (neighbor of B), D, E (neighbors of B and F)</li>
                                        <li>Level 3: H (neighbor of E)</li>
                                    </ul>
                                    <p><strong>Queue:</strong> [C] ‚Üí [B,F,G] ‚Üí [F,G,A] ‚Üí [G,A,D,E] ‚Üí [A,D,E] ‚Üí [D,E] ‚Üí [E,H] ‚Üí [H] ‚Üí []</p>
                                </div>
                            </div>

                            <div class="quiz-box">
                                <h4>üß† Quick Quiz: Test Your BFS Understanding</h4>
                                <div class="quiz-question">
                                    <p><strong>Q1:</strong> What data structure does BFS use?</p>
                                    <div class="quiz-options">
                                        <div class="quiz-option" onclick="checkAnswer(this, false, 'bfs-q1')">A) Stack</div>
                                        <div class="quiz-option" onclick="checkAnswer(this, true, 'bfs-q1')">B) Queue</div>
                                        <div class="quiz-option" onclick="checkAnswer(this, false, 'bfs-q1')">C) Priority Queue</div>
                                        <div class="quiz-option" onclick="checkAnswer(this, false, 'bfs-q1')">D) Hash Table</div>
                                    </div>
                                    <div class="quiz-explanation" id="bfs-q1">
                                        <strong>Correct!</strong> BFS uses a Queue (FIFO - First In First Out) to process vertices level by level. This is the key difference from DFS which uses a stack or recursion.
                                    </div>
                                </div>
                                <div class="quiz-question">
                                    <p><strong>Q2:</strong> In an unweighted graph, BFS finds:</p>
                                    <div class="quiz-options">
                                        <div class="quiz-option" onclick="checkAnswer(this, false, 'bfs-q2')">A) The longest path</div>
                                        <div class="quiz-option" onclick="checkAnswer(this, true, 'bfs-q2')">B) The shortest path</div>
                                        <div class="quiz-option" onclick="checkAnswer(this, false, 'bfs-q2')">C) All possible paths</div>
                                        <div class="quiz-option" onclick="checkAnswer(this, false, 'bfs-q2')">D) The minimum spanning tree</div>
                                    </div>
                                    <div class="quiz-explanation" id="bfs-q2">
                                        <strong>Correct!</strong> BFS guarantees the shortest path in unweighted graphs because it explores nodes level by level, reaching closer nodes first.
                                    </div>
                                </div>
                                <div class="quiz-question">
                                    <p><strong>Q3:</strong> What is the space complexity of BFS?</p>
                                    <div class="quiz-options">
                                        <div class="quiz-option" onclick="checkAnswer(this, false, 'bfs-q3')">A) O(1)</div>
                                        <div class="quiz-option" onclick="checkAnswer(this, false, 'bfs-q3')">B) O(E)</div>
                                        <div class="quiz-option" onclick="checkAnswer(this, true, 'bfs-q3')">C) O(V)</div>
                                        <div class="quiz-option" onclick="checkAnswer(this, false, 'bfs-q3')">D) O(V¬≤)</div>
                                    </div>
                                    <div class="quiz-explanation" id="bfs-q3">
                                        <strong>Correct!</strong> Space complexity is O(V) for the queue and visited array. In the worst case, all vertices might be in the queue at once.
                                    </div>
                                </div>
                            </div>

                            <div class="self-check">
                                <h4>üéØ Self-Check: Can You Explain?</h4>
                                <p>Try explaining these in your own words (cover the answer first!):</p>
                                <ol>
                                    <li><strong>Why does BFS use a queue instead of a stack?</strong>
                                        <button class="show-answer-btn" onclick="toggleAnswer('self-check-1')">Show Answer</button>
                                        <div class="hidden-answer" id="self-check-1">
                                            A queue ensures FIFO (First-In-First-Out) ordering, which means we process vertices in the order we discover them. This guarantees we explore all vertices at distance d before exploring vertices at distance d+1, which is why BFS finds shortest paths.
                                        </div>
                                    </li>
                                    <li><strong>When would you choose BFS over DFS?</strong>
                                        <button class="show-answer-btn" onclick="toggleAnswer('self-check-2')">Show Answer</button>
                                        <div class="hidden-answer" id="self-check-2">
                                            Choose BFS when: (1) You need shortest paths in unweighted graphs, (2) You want to explore nearby nodes first, (3) The solution is likely near the start node. Choose DFS when: (1) You want to explore all paths, (2) Need topological sorting, (3) Detecting cycles, (4) Memory is limited (DFS uses less space in most cases).
                                        </div>
                                    </li>
                                </ol>
                            </div>
                        </div>

                        <div class="subtopic">
                            <h3>Depth-First Search (DFS)</h3>
                            <div class="key-concepts">
                                <h4>Key Concepts:</h4>
                                <ul>
                                    <li><strong>Uses Stack (LIFO)</strong> or recursion - explores as deep as possible first</li>
                                    <li><strong>Time Complexity:</strong> O(V + E)</li>
                                    <li><strong>Space Complexity:</strong> O(V) for recursion stack</li>
                                    <li><strong>Timestamps:</strong> Discovery time d[v] and finish time f[v]</li>
                                    <li><strong>Applications:</strong> Cycle detection, topological sort, SCC, path finding</li>
                                    <li><strong>Edge Classification:</strong> Tree, Back, Forward, Cross edges</li>
                                </ul>
                            </div>
                            <div class="video-recommendations">
                                <h4>Video Recommendations:</h4>
                                <a href="https://www.youtube.com/watch?v=7fujbpJ0LB4" target="_blank" class="video-link">üé• Abdul Bari - DFS Graph Traversal (17 min)</a>
                                <a href="https://www.youtube.com/watch?v=PMMc4VsIacU" target="_blank" class="video-link">üé• MIT OpenCourseWare - DFS and Topological Sort (50 min - if time)</a>
                            </div>
                            <div class="warning-box">
                                <h4>Common Pitfall:</h4>
                                <p>Remember: DFS on an undirected graph only has tree and back edges. Forward and cross edges only appear in directed graphs!</p>
                            </div>
                        </div>

                        <div class="subtopic">
                            <h3>Topological Sort</h3>
                            <div class="key-concepts">
                                <h4>Key Concepts:</h4>
                                <ul>
                                    <li><strong>Only for DAGs</strong> (Directed Acyclic Graphs)</li>
                                    <li><strong>Linear ordering:</strong> If edge u‚Üív exists, u appears before v</li>
                                    <li><strong>Algorithm:</strong> DFS-based - add vertices in reverse finish time order</li>
                                    <li><strong>Time Complexity:</strong> O(V + E)</li>
                                    <li><strong>Cycle Detection:</strong> If back edge found, graph has cycle (no topological sort possible)</li>
                                </ul>
                            </div>
                            <div class="video-recommendations">
                                <h4>Video Recommendations:</h4>
                                <a href="https://www.youtube.com/watch?v=cIBFEhD77b4" target="_blank" class="video-link">üé• William Fiset - Topological Sort (15 min)</a>
                            </div>
                            <div class="practice-tip">
                                <h4>Quick Algorithm:</h4>
                                <ol>
                                    <li>Run DFS on entire graph</li>
                                    <li>When vertex finishes (all descendants explored), push to stack</li>
                                    <li>Pop stack to get topological order</li>
                                </ol>
                            </div>
                        </div>

                        <div class="subtopic">
                            <h3>Strongly Connected Components (SCC)</h3>
                            <div class="key-concepts">
                                <h4>Key Concepts:</h4>
                                <ul>
                                    <li><strong>SCC:</strong> Maximal set of vertices where every vertex is reachable from every other</li>
                                    <li><strong>Kosaraju's Algorithm:</strong> Most common approach</li>
                                    <li><strong>Time Complexity:</strong> O(V + E) - two DFS passes</li>
                                    <li><strong>Steps:</strong> (1) DFS on G to compute finish times, (2) DFS on G^T (transpose) in decreasing finish time order</li>
                                </ul>
                            </div>
                            <div class="video-recommendations">
                                <h4>Video Recommendations:</h4>
                                <a href="https://www.youtube.com/watch?v=RpgcYiky7uw" target="_blank" class="video-link">üé• Tushar Roy - Strongly Connected Components (16 min)</a>
                            </div>
                            <div class="practice-tip">
                                <h4>Walkthrough:</h4>
                                <ol>
                                    <li>Run DFS on original graph G, record finish times</li>
                                    <li>Compute transpose G^T (reverse all edges)</li>
                                    <li>Run DFS on G^T in decreasing finish time order</li>
                                    <li>Each DFS tree in step 3 is one SCC</li>
                                </ol>
                            </div>
                        </div>

                        <div class="subtopic">
                            <h3>Dijkstra's Algorithm (Single-Source Shortest Path)</h3>
                            <div class="key-concepts">
                                <h4>Key Concepts:</h4>
                                <ul>
                                    <li><strong>Requirement:</strong> Non-negative edge weights only!</li>
                                    <li><strong>Greedy approach:</strong> Always pick minimum distance unvisited vertex</li>
                                    <li><strong>Time Complexity:</strong> O((V+E) log V) with min-heap, O(V¬≤) with array</li>
                                    <li><strong>Output:</strong> Shortest paths from source to all vertices</li>
                                    <li><strong>Relaxation:</strong> If d[v] > d[u] + w(u,v), update d[v]</li>
                                </ul>
                            </div>
                            <div class="video-recommendations">
                                <h4>Video Recommendations:</h4>
                                <a href="https://www.youtube.com/watch?v=XB4MIexjvY0" target="_blank" class="video-link">üé• Abdul Bari - Dijkstra's Algorithm (15 min)</a>
                                <a href="https://www.youtube.com/watch?v=pSqmAO-m7Lk" target="_blank" class="video-link">üé• William Fiset - Dijkstra's Shortest Path (12 min)</a>
                            </div>
                            <div class="warning-box">
                                <h4>Critical to Remember:</h4>
                                <p>Dijkstra's FAILS with negative weights! Use Bellman-Ford for negative weights (though this might not be on your exam based on syllabus).</p>
                            </div>
                            <div class="practice-tip">
                                <h4>Algorithm Steps:</h4>
                                <ol>
                                    <li>Initialize: d[source] = 0, d[all others] = ‚àû, min-heap with all vertices</li>
                                    <li>While heap not empty: extract min vertex u</li>
                                    <li>For each neighbor v of u: relax edge (u,v)</li>
                                    <li>Update heap if distance improved</li>
                                </ol>
                            </div>
                        </div>

                        <div class="quick-reference">
                            <h3>Graph Algorithms Quick Reference</h3>
                            <table class="complexity-table">
                                <thead>
                                    <tr>
                                        <th>Algorithm</th>
                                        <th>Time Complexity</th>
                                        <th>Space</th>
                                        <th>Key Use</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr>
                                        <td>BFS</td>
                                        <td>O(V + E)</td>
                                        <td>O(V)</td>
                                        <td>Shortest path (unweighted)</td>
                                    </tr>
                                    <tr>
                                        <td>DFS</td>
                                        <td>O(V + E)</td>
                                        <td>O(V)</td>
                                        <td>Cycle detection, topological sort</td>
                                    </tr>
                                    <tr>
                                        <td>Topological Sort</td>
                                        <td>O(V + E)</td>
                                        <td>O(V)</td>
                                        <td>Task scheduling (DAGs only)</td>
                                    </tr>
                                    <tr>
                                        <td>SCC (Kosaraju)</td>
                                        <td>O(V + E)</td>
                                        <td>O(V)</td>
                                        <td>Find strongly connected components</td>
                                    </tr>
                                    <tr>
                                        <td>Dijkstra</td>
                                        <td>O((V+E) log V)</td>
                                        <td>O(V)</td>
                                        <td>Shortest path (non-negative weights)</td>
                                    </tr>
                                </tbody>
                            </table>
                        </div>

                        <ul class="checklist">
                            <li><input type="checkbox" onchange="updateProgress()"> Understand graph representations</li>
                            <li><input type="checkbox" onchange="updateProgress()"> Can trace BFS step-by-step</li>
                            <li><input type="checkbox" onchange="updateProgress()"> Can trace DFS and identify edge types</li>
                            <li><input type="checkbox" onchange="updateProgress()"> Understand topological sort algorithm</li>
                            <li><input type="checkbox" onchange="updateProgress()"> Can execute Kosaraju's SCC algorithm</li>
                            <li><input type="checkbox" onchange="updateProgress()"> Can trace Dijkstra's algorithm</li>
                            <li><input type="checkbox" onchange="updateProgress()"> Review problem sets ps1-ps3</li>
                        </ul>
                    </div>
                </div>

                <!-- DIVIDE AND CONQUER SECTION -->
                <div class="topic-section" id="divide-conquer">
                    <h2 onclick="toggleSection('divide-conquer')">
                        <span class="toggle-icon">‚ñº</span>
                        2. Divide and Conquer
                    </h2>
                    <div class="topic-content">
                        <div class="subtopic">
                            <h3>Matrix Multiplication</h3>
                            <div class="key-concepts">
                                <h4>Key Concepts:</h4>
                                <ul>
                                    <li><strong>Standard Algorithm:</strong> O(n¬≥) time - three nested loops</li>
                                    <li><strong>Divide & Conquer:</strong> Split matrices into submatrices</li>
                                    <li><strong>Naive D&C:</strong> Still O(n¬≥) - T(n) = 8T(n/2) + O(n¬≤)</li>
                                    <li><strong>Key Idea:</strong> Reduce number of recursive multiplications</li>
                                </ul>
                            </div>
                        </div>

                        <div class="subtopic">
                            <h3>Strassen's Algorithm</h3>
                            <div class="key-concepts">
                                <h4>Key Concepts:</h4>
                                <ul>
                                    <li><strong>Innovation:</strong> Reduces 8 multiplications to 7 using clever additions</li>
                                    <li><strong>Time Complexity:</strong> O(n^2.81) - better than O(n¬≥)</li>
                                    <li><strong>Recurrence:</strong> T(n) = 7T(n/2) + O(n¬≤)</li>
                                    <li><strong>Trade-off:</strong> More additions/subtractions, but fewer multiplications</li>
                                </ul>
                            </div>
                            <div class="video-recommendations">
                                <h4>Video Recommendations:</h4>
                                <a href="https://www.youtube.com/watch?v=0oJyNmEbS4w" target="_blank" class="video-link">üé• Abdul Bari - Strassen's Matrix Multiplication (20 min)</a>
                            </div>
                            <div class="practice-tip">
                                <h4>Focus:</h4>
                                <p>Know WHY Strassen is faster (7 vs 8 multiplications) and how to apply Master Theorem to analyze it. You likely won't need to memorize the exact 7 formulas.</p>
                            </div>
                        </div>

                        <div class="subtopic">
                            <h3>Solving Recurrences - Substitution Method</h3>
                            <div class="key-concepts">
                                <h4>Key Concepts:</h4>
                                <ul>
                                    <li><strong>Process:</strong> (1) Guess the solution, (2) Prove by induction</li>
                                    <li><strong>Guess Strategies:</strong> Use recursion tree or Master Theorem as guide</li>
                                    <li><strong>Induction:</strong> Assume true for smaller values, prove for n</li>
                                    <li><strong>Common Pattern:</strong> Prove T(n) ‚â§ c¬∑f(n) for some constant c</li>
                                </ul>
                            </div>
                            <div class="video-recommendations">
                                <h4>Video Recommendations:</h4>
                                <a href="https://www.youtube.com/watch?v=1K9ebQJosN8" target="_blank" class="video-link">üé• MIT OCW - Substitution Method (20 min segment)</a>
                            </div>
                        </div>

                        <div class="subtopic">
                            <h3>Recursion Tree Method</h3>
                            <div class="key-concepts">
                                <h4>Key Concepts:</h4>
                                <ul>
                                    <li><strong>Visual approach:</strong> Draw tree showing recursive calls</li>
                                    <li><strong>Each level:</strong> Shows work done at that recursion depth</li>
                                    <li><strong>Sum all levels:</strong> Get total work = solution</li>
                                    <li><strong>Steps:</strong> (1) Draw tree, (2) Calculate work per level, (3) Sum geometric series</li>
                                </ul>
                            </div>
                            <div class="practice-tip">
                                <h4>Example: T(n) = 2T(n/2) + n</h4>
                                <ol>
                                    <li>Root: n work, 2 children of size n/2</li>
                                    <li>Level 1: 2¬∑(n/2) = n work total</li>
                                    <li>Level 2: 4¬∑(n/4) = n work total</li>
                                    <li>Height: log n levels, each with n work</li>
                                    <li>Total: n¬∑log n = O(n log n)</li>
                                </ol>
                            </div>
                        </div>

                        <div class="subtopic">
                            <h3>Master Theorem (Most Important!)</h3>
                            <div class="key-concepts">
                                <h4>For recurrences: T(n) = aT(n/b) + f(n)</h4>
                                <ul>
                                    <li><strong>Compare f(n) with n^(log_b a):</strong></li>
                                    <li><strong>Case 1:</strong> If f(n) = O(n^(log_b a - Œµ)) for Œµ > 0, then T(n) = Œò(n^(log_b a))</li>
                                    <li><strong>Case 2:</strong> If f(n) = Œò(n^(log_b a)), then T(n) = Œò(n^(log_b a) log n)</li>
                                    <li><strong>Case 3:</strong> If f(n) = Œ©(n^(log_b a + Œµ)) for Œµ > 0, AND regularity condition holds, then T(n) = Œò(f(n))</li>
                                </ul>
                            </div>
                            <div class="formula">
                                Critical value: n^(log_b a)
                                <br>For T(n) = aT(n/b) + f(n), calculate log_b(a) first!
                            </div>
                            <div class="video-recommendations">
                                <h4>Video Recommendations:</h4>
                                <a href="https://www.youtube.com/watch?v=OynWkEj0S-s" target="_blank" class="video-link">üé• Abdul Bari - Master Theorem (23 min)</a>
                                <a href="https://www.youtube.com/watch?v=2H0GKdrIowU" target="_blank" class="video-link">üé• Back to Back SWE - Master Theorem Explained (12 min)</a>
                            </div>
                            <div class="practice-tip">
                                <h4>Quick Examples:</h4>
                                <ul>
                                    <li><strong>T(n) = 2T(n/2) + n:</strong> a=2, b=2, f(n)=n. log‚ÇÇ2 = 1, n¬π=n. Case 2! ‚Üí O(n log n)</li>
                                    <li><strong>T(n) = 4T(n/2) + n:</strong> a=4, b=2, f(n)=n. log‚ÇÇ4 = 2, n¬≤ > n. Case 1! ‚Üí O(n¬≤)</li>
                                    <li><strong>T(n) = 2T(n/2) + n¬≤:</strong> a=2, b=2, f(n)=n¬≤. log‚ÇÇ2 = 1, n¬≤ > n¬π. Case 3! ‚Üí O(n¬≤)</li>
                                    <li><strong>T(n) = 7T(n/2) + n¬≤:</strong> a=7, b=2, f(n)=n¬≤. log‚ÇÇ7 ‚âà 2.81, n^2.81 > n¬≤. Case 1! ‚Üí O(n^2.81)</li>
                                </ul>
                            </div>
                            <div class="warning-box">
                                <h4>Master Theorem Limitations:</h4>
                                <p>Doesn't apply to: T(n) = 2T(n/2) + n log n (gap isn't polynomial), or when a < 1, or b ‚â§ 1.</p>
                            </div>

                            <div class="visual-section">
                                <h4>üìä Complexity Growth Visualization</h4>
                                <div class="graph-container">
                                    <svg width="700" height="400" viewBox="0 0 700 400">
                                        <!-- Axes -->
                                        <line x1="50" y1="350" x2="650" y2="350" stroke="#333" stroke-width="2"/>
                                        <line x1="50" y1="350" x2="50" y2="30" stroke="#333" stroke-width="2"/>
                                        <text x="350" y="385" text-anchor="middle">Input Size (n)</text>
                                        <text x="20" y="200" text-anchor="middle" transform="rotate(-90 20 200)">Operations</text>

                                        <!-- O(log n) curve -->
                                        <path d="M 50 350 Q 200 250, 650 150" stroke="#4caf50" stroke-width="3" fill="none"/>
                                        <text x="660" y="155" fill="#4caf50" font-weight="bold">O(log n)</text>

                                        <!-- O(n) curve -->
                                        <path d="M 50 350 L 650 80" stroke="#2196f3" stroke-width="3" fill="none"/>
                                        <text x="660" y="85" fill="#2196f3" font-weight="bold">O(n)</text>

                                        <!-- O(n log n) curve -->
                                        <path d="M 50 350 Q 300 150, 650 50" stroke="#ff9800" stroke-width="3" fill="none"/>
                                        <text x="660" y="55" fill="#ff9800" font-weight="bold">O(n log n)</text>

                                        <!-- O(n¬≤) curve -->
                                        <path d="M 50 350 Q 200 200, 400 50 Q 500 30, 650 30" stroke="#f44336" stroke-width="3" fill="none"/>
                                        <text x="500" y="25" fill="#f44336" font-weight="bold">O(n¬≤)</text>

                                        <!-- O(2‚Åø) curve -->
                                        <path d="M 50 350 L 150 340 Q 200 250, 250 100 Q 280 40, 300 35" stroke="#9c27b0" stroke-width="3" fill="none"/>
                                        <text x="310" y="40" fill="#9c27b0" font-weight="bold">O(2‚Åø)</text>

                                        <!-- Grid lines -->
                                        <line x1="50" y1="280" x2="650" y2="280" stroke="#ddd" stroke-width="1" stroke-dasharray="5,5"/>
                                        <line x1="50" y1="210" x2="650" y2="210" stroke="#ddd" stroke-width="1" stroke-dasharray="5,5"/>
                                        <line x1="50" y1="140" x2="650" y2="140" stroke="#ddd" stroke-width="1" stroke-dasharray="5,5"/>
                                        <line x1="50" y1="70" x2="650" y2="70" stroke="#ddd" stroke-width="1" stroke-dasharray="5,5"/>
                                    </svg>
                                </div>
                                <p><strong>Key insight:</strong> Notice how quickly O(n¬≤) and O(2‚Åø) grow compared to O(n log n). This is why divide & conquer algorithms like merge sort (O(n log n)) are much better than bubble sort (O(n¬≤)) for large inputs!</p>
                            </div>

                            <div class="quiz-box">
                                <h4>üß† Master Theorem Practice Quiz</h4>
                                <div class="quiz-question">
                                    <p><strong>Q1:</strong> For T(n) = 3T(n/4) + n, what is n^(log_b a)?</p>
                                    <div class="quiz-options">
                                        <div class="quiz-option" onclick="checkAnswer(this, false, 'master-q1')">A) n</div>
                                        <div class="quiz-option" onclick="checkAnswer(this, true, 'master-q1')">B) n^0.79 (approximately)</div>
                                        <div class="quiz-option" onclick="checkAnswer(this, false, 'master-q1')">C) n¬≤</div>
                                        <div class="quiz-option" onclick="checkAnswer(this, false, 'master-q1')">D) n^3</div>
                                    </div>
                                    <div class="quiz-explanation" id="master-q1">
                                        <strong>Correct!</strong> a=3, b=4, so log‚ÇÑ3 ‚âà 0.79. Therefore n^(log_b a) = n^0.79
                                    </div>
                                </div>
                                <div class="quiz-question">
                                    <p><strong>Q2:</strong> For T(n) = 3T(n/4) + n, which case applies?</p>
                                    <div class="quiz-options">
                                        <div class="quiz-option" onclick="checkAnswer(this, false, 'master-q2')">A) Case 1</div>
                                        <div class="quiz-option" onclick="checkAnswer(this, false, 'master-q2')">B) Case 2</div>
                                        <div class="quiz-option" onclick="checkAnswer(this, true, 'master-q2')">C) Case 3</div>
                                        <div class="quiz-option" onclick="checkAnswer(this, false, 'master-q2')">D) Master Theorem doesn't apply</div>
                                    </div>
                                    <div class="quiz-explanation" id="master-q2">
                                        <strong>Correct!</strong> f(n) = n and n^(log‚ÇÑ3) ‚âà n^0.79. Since n > n^0.79 polynomially (n = n^1), this is Case 3, so T(n) = Œò(n).
                                    </div>
                                </div>
                                <div class="quiz-question">
                                    <p><strong>Q3:</strong> For T(n) = 8T(n/2) + n¬≤, what is the solution?</p>
                                    <div class="quiz-options">
                                        <div class="quiz-option" onclick="checkAnswer(this, false, 'master-q3')">A) Œò(n¬≤)</div>
                                        <div class="quiz-option" onclick="checkAnswer(this, false, 'master-q3')">B) Œò(n¬≤ log n)</div>
                                        <div class="quiz-option" onclick="checkAnswer(this, true, 'master-q3')">C) Œò(n¬≥)</div>
                                        <div class="quiz-option" onclick="checkAnswer(this, false, 'master-q3')">D) Œò(n^4)</div>
                                    </div>
                                    <div class="quiz-explanation" id="master-q3">
                                        <strong>Correct!</strong> a=8, b=2, log‚ÇÇ8 = 3, so n^(log_b a) = n¬≥. f(n) = n¬≤ < n¬≥, so Case 1 applies ‚Üí T(n) = Œò(n¬≥).
                                    </div>
                                </div>
                            </div>

                            <div class="trace-exercise">
                                <h4>‚úèÔ∏è Interactive Practice: Solve These Step-by-Step</h4>
                                <div class="trace-step">
                                    <div class="trace-step-header">Problem 1: T(n) = 9T(n/3) + n</div>
                                    <p>Step 1: Identify a, b, f(n)</p>
                                    <button class="show-answer-btn" onclick="toggleAnswer('master-trace-1a')">Show Step 1</button>
                                    <div class="hidden-answer" id="master-trace-1a">
                                        a = 9, b = 3, f(n) = n
                                    </div>
                                    <p>Step 2: Calculate n^(log_b a)</p>
                                    <button class="show-answer-btn" onclick="toggleAnswer('master-trace-1b')">Show Step 2</button>
                                    <div class="hidden-answer" id="master-trace-1b">
                                        log‚ÇÉ9 = 2, so n^(log_b a) = n¬≤
                                    </div>
                                    <p>Step 3: Compare f(n) with n^(log_b a)</p>
                                    <button class="show-answer-btn" onclick="toggleAnswer('master-trace-1c')">Show Step 3</button>
                                    <div class="hidden-answer" id="master-trace-1c">
                                        f(n) = n, n^(log_b a) = n¬≤. Since n < n¬≤ polynomially, this is Case 1.
                                    </div>
                                    <p>Step 4: Apply the case and get final answer</p>
                                    <button class="show-answer-btn" onclick="toggleAnswer('master-trace-1d')">Show Final Answer</button>
                                    <div class="hidden-answer" id="master-trace-1d">
                                        <strong>Case 1 applies ‚Üí T(n) = Œò(n¬≤)</strong>
                                    </div>
                                </div>

                                <div class="trace-step">
                                    <div class="trace-step-header">Problem 2: T(n) = 2T(n/4) + ‚àön</div>
                                    <p>Try this one yourself! Click to reveal each step.</p>
                                    <button class="show-answer-btn" onclick="toggleAnswer('master-trace-2')">Show Complete Solution</button>
                                    <div class="hidden-answer" id="master-trace-2">
                                        <p>a = 2, b = 4, f(n) = ‚àön = n^0.5</p>
                                        <p>log‚ÇÑ2 = 0.5, so n^(log_b a) = n^0.5</p>
                                        <p>f(n) = n^0.5 equals n^(log_b a) = n^0.5</p>
                                        <p><strong>Case 2 applies ‚Üí T(n) = Œò(n^0.5 log n) = Œò(‚àön log n)</strong></p>
                                    </div>
                                </div>
                            </div>
                        </div>

                        <div class="quick-reference">
                            <h3>Master Theorem Cheat Sheet</h3>
                            <div class="formula">
                                T(n) = aT(n/b) + f(n)
                                <br><br>
                                Step 1: Calculate n^(log_b a)
                                <br>Step 2: Compare f(n) to n^(log_b a)
                                <br>Step 3: Apply appropriate case
                            </div>
                        </div>

                        <ul class="checklist">
                            <li><input type="checkbox" onchange="updateProgress()"> Understand standard vs D&C matrix multiplication</li>
                            <li><input type="checkbox" onchange="updateProgress()"> Know why Strassen is O(n^2.81)</li>
                            <li><input type="checkbox" onchange="updateProgress()"> Can solve recurrences using substitution</li>
                            <li><input type="checkbox" onchange="updateProgress()"> Can draw and analyze recursion trees</li>
                            <li><input type="checkbox" onchange="updateProgress()"> Master Master Theorem - all 3 cases!</li>
                            <li><input type="checkbox" onchange="updateProgress()"> Practice 5+ Master Theorem examples</li>
                            <li><input type="checkbox" onchange="updateProgress()"> Review problem set ps3-ps4</li>
                        </ul>
                    </div>
                </div>

                <!-- GREEDY ALGORITHMS SECTION -->
                <div class="topic-section" id="greedy">
                    <h2 onclick="toggleSection('greedy')">
                        <span class="toggle-icon">‚ñº</span>
                        3. Greedy Algorithms
                    </h2>
                    <div class="topic-content">
                        <div class="subtopic">
                            <h3>Greedy Strategy Overview</h3>
                            <div class="key-concepts">
                                <h4>Key Concepts:</h4>
                                <ul>
                                    <li><strong>Greedy Choice Property:</strong> Optimal solution contains greedy choice</li>
                                    <li><strong>Optimal Substructure:</strong> Optimal solution contains optimal solutions to subproblems</li>
                                    <li><strong>Proof Pattern:</strong> Show greedy choice is safe (exchange argument), then prove optimal substructure</li>
                                    <li><strong>vs Dynamic Programming:</strong> Greedy makes one choice and never reconsiders, DP tries all choices</li>
                                </ul>
                            </div>
                            <div class="warning-box">
                                <h4>When Greedy Fails:</h4>
                                <p>Greedy doesn't always work! Example: Making change with arbitrary coin denominations, or finding shortest path in graphs with negative weights.</p>
                            </div>
                        </div>

                        <div class="subtopic">
                            <h3>Activity Selection Problem</h3>
                            <div class="key-concepts">
                                <h4>Key Concepts:</h4>
                                <ul>
                                    <li><strong>Problem:</strong> Select maximum number of non-overlapping activities</li>
                                    <li><strong>Greedy Choice:</strong> Always pick activity with earliest finish time</li>
                                    <li><strong>Time Complexity:</strong> O(n log n) for sorting + O(n) for selection</li>
                                    <li><strong>Why it works:</strong> Early finish leaves most room for remaining activities</li>
                                </ul>
                            </div>
                            <div class="practice-tip">
                                <h4>Algorithm:</h4>
                                <ol>
                                    <li>Sort activities by finish time</li>
                                    <li>Select first activity</li>
                                    <li>For each remaining activity: if start ‚â• last finish, select it</li>
                                </ol>
                            </div>
                        </div>

                        <div class="subtopic">
                            <h3>Huffman Codes</h3>
                            <div class="key-concepts">
                                <h4>Key Concepts:</h4>
                                <ul>
                                    <li><strong>Purpose:</strong> Optimal prefix-free binary encoding</li>
                                    <li><strong>Greedy Choice:</strong> Merge two lowest-frequency nodes repeatedly</li>
                                    <li><strong>Time Complexity:</strong> O(n log n) with min-heap</li>
                                    <li><strong>Result:</strong> Variable-length codes, frequent chars get shorter codes</li>
                                    <li><strong>Optimality:</strong> Produces minimum average code length</li>
                                </ul>
                            </div>
                            <div class="video-recommendations">
                                <h4>Video Recommendations:</h4>
                                <a href="https://www.youtube.com/watch?v=co4_ahEDCho" target="_blank" class="video-link">üé• Abdul Bari - Huffman Coding (23 min)</a>
                                <a href="https://www.youtube.com/watch?v=JsTptu56GM8" target="_blank" class="video-link">üé• Tom Scott - Huffman Codes (9 min - quick overview)</a>
                            </div>
                            <div class="practice-tip">
                                <h4>Algorithm Steps:</h4>
                                <ol>
                                    <li>Create leaf node for each character with its frequency</li>
                                    <li>Build min-heap with all nodes</li>
                                    <li>While heap has > 1 node:
                                        <ul>
                                            <li>Extract two minimum nodes</li>
                                            <li>Create new internal node with frequency = sum of two nodes</li>
                                            <li>Make extracted nodes children, insert new node into heap</li>
                                        </ul>
                                    </li>
                                    <li>Remaining node is root of Huffman tree</li>
                                    <li>Assign codes: left=0, right=1 (or vice versa)</li>
                                </ol>
                            </div>
                        </div>

                        <div class="subtopic">
                            <h3>Minimum Spanning Trees (MST)</h3>
                            <div class="key-concepts">
                                <h4>Key Concepts:</h4>
                                <ul>
                                    <li><strong>MST:</strong> Connects all vertices with minimum total edge weight, no cycles</li>
                                    <li><strong>Properties:</strong> Tree with V-1 edges, unique if edge weights are distinct</li>
                                    <li><strong>Generic MST:</strong> Grow tree by adding safe edges (edges that maintain MST property)</li>
                                    <li><strong>Cut Property:</strong> Light edge crossing cut is safe to add</li>
                                </ul>
                            </div>
                        </div>

                        <div class="subtopic">
                            <h3>Kruskal's Algorithm</h3>
                            <div class="key-concepts">
                                <h4>Key Concepts:</h4>
                                <ul>
                                    <li><strong>Strategy:</strong> Edge-based - sort edges, add if doesn't create cycle</li>
                                    <li><strong>Data Structure:</strong> Union-Find (Disjoint Set) for cycle detection</li>
                                    <li><strong>Time Complexity:</strong> O(E log E) or O(E log V) - dominated by sorting</li>
                                    <li><strong>Greedy Choice:</strong> Always add minimum weight edge that doesn't form cycle</li>
                                </ul>
                            </div>
                            <div class="video-recommendations">
                                <h4>Video Recommendations:</h4>
                                <a href="https://www.youtube.com/watch?v=4ZlRH0eK-qQ" target="_blank" class="video-link">üé• Abdul Bari - Kruskal's Algorithm (12 min)</a>
                            </div>
                            <div class="practice-tip">
                                <h4>Algorithm:</h4>
                                <ol>
                                    <li>Sort all edges by weight (ascending)</li>
                                    <li>Initialize: Each vertex in its own set (Union-Find)</li>
                                    <li>For each edge (u,v) in sorted order:
                                        <ul>
                                            <li>If u and v in different sets: add edge to MST, union sets</li>
                                            <li>Else: skip (would create cycle)</li>
                                        </ul>
                                    </li>
                                    <li>Stop when MST has V-1 edges</li>
                                </ol>
                            </div>
                        </div>

                        <div class="subtopic">
                            <h3>Prim's Algorithm</h3>
                            <div class="key-concepts">
                                <h4>Key Concepts:</h4>
                                <ul>
                                    <li><strong>Strategy:</strong> Vertex-based - grow tree from single vertex</li>
                                    <li><strong>Data Structure:</strong> Min-heap (priority queue) for selecting minimum weight edge</li>
                                    <li><strong>Time Complexity:</strong> O((V+E) log V) with binary heap, O(E + V log V) with Fibonacci heap</li>
                                    <li><strong>Greedy Choice:</strong> Add minimum weight edge connecting tree to non-tree vertex</li>
                                    <li><strong>Similar to:</strong> Dijkstra's algorithm (both use priority queue, grow from source)</li>
                                </ul>
                            </div>
                            <div class="video-recommendations">
                                <h4>Video Recommendations:</h4>
                                <a href="https://www.youtube.com/watch?v=oP2-8ysT3QQ" target="_blank" class="video-link">üé• Abdul Bari - Prim's Algorithm (14 min)</a>
                                <a href="https://www.youtube.com/watch?v=cplfcGZmX7I" target="_blank" class="video-link">üé• William Fiset - Prim's MST (13 min)</a>
                            </div>
                            <div class="practice-tip">
                                <h4>Algorithm:</h4>
                                <ol>
                                    <li>Start with arbitrary vertex, add to MST</li>
                                    <li>Initialize: key[v] = ‚àû for all vertices, key[start] = 0</li>
                                    <li>While MST doesn't include all vertices:
                                        <ul>
                                            <li>Extract min key vertex u from heap (not yet in MST)</li>
                                            <li>Add u to MST</li>
                                            <li>For each neighbor v of u: if v not in MST and weight(u,v) < key[v], update key[v]</li>
                                        </ul>
                                    </li>
                                </ol>
                            </div>
                        </div>

                        <div class="quick-reference">
                            <h3>Greedy Algorithms Comparison</h3>
                            <table class="complexity-table">
                                <thead>
                                    <tr>
                                        <th>Algorithm</th>
                                        <th>Problem</th>
                                        <th>Greedy Choice</th>
                                        <th>Time Complexity</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr>
                                        <td>Activity Selection</td>
                                        <td>Max non-overlapping activities</td>
                                        <td>Earliest finish time</td>
                                        <td>O(n log n)</td>
                                    </tr>
                                    <tr>
                                        <td>Huffman</td>
                                        <td>Optimal prefix codes</td>
                                        <td>Merge two min frequencies</td>
                                        <td>O(n log n)</td>
                                    </tr>
                                    <tr>
                                        <td>Kruskal's MST</td>
                                        <td>Minimum spanning tree</td>
                                        <td>Min weight edge (no cycle)</td>
                                        <td>O(E log E)</td>
                                    </tr>
                                    <tr>
                                        <td>Prim's MST</td>
                                        <td>Minimum spanning tree</td>
                                        <td>Min edge to new vertex</td>
                                        <td>O((V+E) log V)</td>
                                    </tr>
                                    <tr>
                                        <td>Dijkstra's</td>
                                        <td>Shortest paths</td>
                                        <td>Min distance unvisited vertex</td>
                                        <td>O((V+E) log V)</td>
                                    </tr>
                                </tbody>
                            </table>
                        </div>

                        <ul class="checklist">
                            <li><input type="checkbox" onchange="updateProgress()"> Understand greedy choice property</li>
                            <li><input type="checkbox" onchange="updateProgress()"> Can solve activity selection</li>
                            <li><input type="checkbox" onchange="updateProgress()"> Can build Huffman tree and assign codes</li>
                            <li><input type="checkbox" onchange="updateProgress()"> Understand MST properties</li>
                            <li><input type="checkbox" onchange="updateProgress()"> Can trace Kruskal's algorithm</li>
                            <li><input type="checkbox" onchange="updateProgress()"> Can trace Prim's algorithm</li>
                            <li><input type="checkbox" onchange="updateProgress()"> Know when Kruskal vs Prim is better</li>
                            <li><input type="checkbox" onchange="updateProgress()"> Review problem sets ps4-ps5</li>
                        </ul>
                    </div>
                </div>

                <!-- DYNAMIC PROGRAMMING SECTION -->
                <div class="topic-section" id="dynamic">
                    <h2 onclick="toggleSection('dynamic')">
                        <span class="toggle-icon">‚ñº</span>
                        4. Dynamic Programming
                    </h2>
                    <div class="topic-content">
                        <div class="subtopic">
                            <h3>Dynamic Programming Principles</h3>
                            <div class="key-concepts">
                                <h4>Key Concepts:</h4>
                                <ul>
                                    <li><strong>When to use DP:</strong> Optimal substructure + overlapping subproblems</li>
                                    <li><strong>Optimal Substructure:</strong> Optimal solution contains optimal solutions to subproblems</li>
                                    <li><strong>Overlapping Subproblems:</strong> Same subproblems computed multiple times</li>
                                    <li><strong>Memoization:</strong> Top-down with caching (recursive)</li>
                                    <li><strong>Tabulation:</strong> Bottom-up with table (iterative)</li>
                                    <li><strong>Steps:</strong> (1) Define subproblems, (2) Relate subproblems (recurrence), (3) Compute bottom-up or memoize top-down</li>
                                </ul>
                            </div>
                            <div class="video-recommendations">
                                <h4>Video Recommendations:</h4>
                                <a href="https://www.youtube.com/watch?v=oBt53YbR9Kk" target="_blank" class="video-link">üé• MIT OCW - Dynamic Programming Overview (48 min - comprehensive)</a>
                                <a href="https://www.youtube.com/watch?v=OQ5jsbhAv_M" target="_blank" class="video-link">üé• CS Dojo - DP Intro (11 min)</a>
                            </div>
                            <div class="warning-box">
                                <h4>DP vs Greedy vs Divide & Conquer:</h4>
                                <ul>
                                    <li><strong>Greedy:</strong> Makes one choice, never reconsiders (fast, doesn't always work)</li>
                                    <li><strong>D&C:</strong> Independent subproblems, no overlap</li>
                                    <li><strong>DP:</strong> Overlapping subproblems, tries all choices, saves results</li>
                                </ul>
                            </div>
                        </div>

                        <div class="subtopic">
                            <h3>Classic DP Problems (Examples to Study)</h3>
                            <div class="key-concepts">
                                <h4>Common Patterns:</h4>
                                <ul>
                                    <li><strong>Rod Cutting:</strong> Max revenue by cutting rod into pieces</li>
                                    <li><strong>Matrix Chain Multiplication:</strong> Optimal parenthesization for min scalar multiplications</li>
                                    <li><strong>Longest Common Subsequence (LCS):</strong> Longest subsequence common to two sequences</li>
                                    <li><strong>Optimal Binary Search Trees:</strong> BST with min expected search cost</li>
                                    <li><strong>0/1 Knapsack:</strong> Max value with weight constraint (items can't be split)</li>
                                </ul>
                            </div>
                            <div class="practice-tip">
                                <h4>Study Approach:</h4>
                                <p>For each problem: (1) Understand the problem, (2) Identify subproblem structure, (3) Write recurrence relation, (4) Understand base cases, (5) Trace through small example.</p>
                            </div>
                        </div>

                        <div class="subtopic">
                            <h3>Rod Cutting Example</h3>
                            <div class="key-concepts">
                                <h4>Problem:</h4>
                                <p>Given rod of length n and prices p[i] for lengths i=1..n, find maximum revenue by cutting rod.</p>
                                <h4>Recurrence:</h4>
                                <div class="formula">
                                    r[n] = max(p[i] + r[n-i]) for i = 1 to n
                                    <br>r[0] = 0 (base case)
                                </div>
                                <ul>
                                    <li><strong>Subproblems:</strong> r[i] = max revenue for rod of length i</li>
                                    <li><strong>Time:</strong> O(n¬≤) with DP, exponential without</li>
                                </ul>
                            </div>
                        </div>

                        <div class="subtopic">
                            <h3>Matrix Chain Multiplication</h3>
                            <div class="key-concepts">
                                <h4>Problem:</h4>
                                <p>Given chain of matrices, find optimal parenthesization to minimize scalar multiplications.</p>
                                <h4>Key Points:</h4>
                                <ul>
                                    <li><strong>Not computing product!</strong> Just finding optimal order</li>
                                    <li><strong>Subproblems:</strong> m[i,j] = min cost to multiply matrices i through j</li>
                                    <li><strong>Recurrence:</strong> m[i,j] = min{m[i,k] + m[k+1,j] + p[i-1]¬∑p[k]¬∑p[j]} for k=i to j-1</li>
                                    <li><strong>Time:</strong> O(n¬≥)</li>
                                </ul>
                            </div>
                            <div class="video-recommendations">
                                <h4>Video Recommendations:</h4>
                                <a href="https://www.youtube.com/watch?v=prx1psByp7U" target="_blank" class="video-link">üé• Abdul Bari - Matrix Chain Multiplication (29 min)</a>
                            </div>
                        </div>

                        <div class="subtopic">
                            <h3>Longest Common Subsequence (LCS)</h3>
                            <div class="key-concepts">
                                <h4>Problem:</h4>
                                <p>Find longest subsequence common to two sequences (not necessarily contiguous).</p>
                                <h4>Recurrence:</h4>
                                <div class="formula">
                                    If X[i] == Y[j]: LCS[i,j] = LCS[i-1,j-1] + 1
                                    <br>Else: LCS[i,j] = max(LCS[i-1,j], LCS[i,j-1])
                                </div>
                                <ul>
                                    <li><strong>Table:</strong> 2D array, size (m+1) √ó (n+1)</li>
                                    <li><strong>Time:</strong> O(mn)</li>
                                    <li><strong>Space:</strong> O(mn), can be optimized to O(min(m,n))</li>
                                </ul>
                            </div>
                            <div class="video-recommendations">
                                <h4>Video Recommendations:</h4>
                                <a href="https://www.youtube.com/watch?v=ASoaQq66foQ" target="_blank" class="video-link">üé• Back to Back SWE - LCS (15 min)</a>
                            </div>
                        </div>

                        <div class="practice-tip">
                            <h4>DP Problem-Solving Template:</h4>
                            <ol>
                                <li><strong>Define subproblems:</strong> What does DP[i] or DP[i][j] represent?</li>
                                <li><strong>Find recurrence:</strong> How to compute DP[i] from smaller subproblems?</li>
                                <li><strong>Base cases:</strong> What are the initial/boundary values?</li>
                                <li><strong>Computation order:</strong> Bottom-up or top-down? What order to fill table?</li>
                                <li><strong>Reconstruct solution:</strong> How to trace back to get actual solution (not just optimal value)?</li>
                            </ol>
                        </div>

                        <div class="resources-section">
                            <h3>Additional DP Resources:</h3>
                            <p>Check your problem sets (ps6-ps7) for specific DP problems covered in your course. Practice is key for DP!</p>
                        </div>

                        <ul class="checklist">
                            <li><input type="checkbox" onchange="updateProgress()"> Understand optimal substructure vs overlapping subproblems</li>
                            <li><input type="checkbox" onchange="updateProgress()"> Know difference between memoization and tabulation</li>
                            <li><input type="checkbox" onchange="updateProgress()"> Can solve rod cutting problem</li>
                            <li><input type="checkbox" onchange="updateProgress()"> Understand matrix chain multiplication</li>
                            <li><input type="checkbox" onchange="updateProgress()"> Can solve LCS problem</li>
                            <li><input type="checkbox" onchange="updateProgress()"> Practice writing recurrence relations</li>
                            <li><input type="checkbox" onchange="updateProgress()"> Review problem sets ps6-ps7</li>
                        </ul>
                    </div>
                </div>

                <!-- MAXIMUM FLOW SECTION -->
                <div class="topic-section" id="maxflow">
                    <h2 onclick="toggleSection('maxflow')">
                        <span class="toggle-icon">‚ñº</span>
                        5. Maximum Flow
                    </h2>
                    <div class="topic-content">
                        <div class="subtopic">
                            <h3>Flow Networks</h3>
                            <div class="key-concepts">
                                <h4>Key Concepts:</h4>
                                <ul>
                                    <li><strong>Flow Network:</strong> Directed graph with source s, sink t, and edge capacities c(u,v)</li>
                                    <li><strong>Flow Properties:</strong>
                                        <ul>
                                            <li>Capacity constraint: 0 ‚â§ f(u,v) ‚â§ c(u,v)</li>
                                            <li>Flow conservation: Flow in = Flow out (except s and t)</li>
                                        </ul>
                                    </li>
                                    <li><strong>Max Flow:</strong> Maximum flow from s to t</li>
                                    <li><strong>Cut:</strong> Partition of vertices into S and T where s‚ààS, t‚ààT</li>
                                    <li><strong>Min-Cut:</strong> Cut with minimum capacity</li>
                                </ul>
                            </div>
                            <div class="formula">
                                Max-Flow Min-Cut Theorem: Maximum flow value = Minimum cut capacity
                            </div>
                        </div>

                        <div class="subtopic">
                            <h3>Ford-Fulkerson Method</h3>
                            <div class="key-concepts">
                                <h4>Key Concepts:</h4>
                                <ul>
                                    <li><strong>Method (not specific algorithm):</strong> Framework using augmenting paths</li>
                                    <li><strong>Augmenting Path:</strong> Path from s to t in residual graph with available capacity</li>
                                    <li><strong>Residual Graph:</strong> Shows remaining capacity after current flow</li>
                                    <li><strong>Residual Capacity:</strong> c_f(u,v) = c(u,v) - f(u,v) + f(v,u)</li>
                                    <li><strong>Time Complexity:</strong> O(E¬∑|f*|) where |f*| is max flow (depends on path-finding method)</li>
                                </ul>
                            </div>
                            <div class="video-recommendations">
                                <h4>Video Recommendations:</h4>
                                <a href="https://www.youtube.com/watch?v=Tl90tNtKvxs" target="_blank" class="video-link">üé• MIT OCW - Max Flow (47 min)</a>
                                <a href="https://www.youtube.com/watch?v=LdOnanfc5TM" target="_blank" class="video-link">üé• William Fiset - Ford-Fulkerson (10 min)</a>
                                <a href="https://www.youtube.com/watch?v=GiN3jRdgxU4" target="_blank" class="video-link">üé• Reducible - Max Flow (16 min - great visualization)</a>
                            </div>
                            <div class="practice-tip">
                                <h4>Algorithm:</h4>
                                <ol>
                                    <li>Initialize: f(u,v) = 0 for all edges</li>
                                    <li>While there exists augmenting path p in residual graph G_f:
                                        <ul>
                                            <li>Find bottleneck capacity c_f(p) = min capacity along p</li>
                                            <li>Augment flow along p by c_f(p)</li>
                                            <li>Update residual graph</li>
                                        </ul>
                                    </li>
                                    <li>Return total flow</li>
                                </ol>
                            </div>
                            <div class="warning-box">
                                <h4>Important Note:</h4>
                                <p>Ford-Fulkerson might not terminate with irrational capacities! Use Edmonds-Karp (BFS for paths) for polynomial time: O(VE¬≤).</p>
                            </div>
                        </div>

                        <div class="subtopic">
                            <h3>Edmonds-Karp Algorithm</h3>
                            <div class="key-concepts">
                                <h4>Key Points:</h4>
                                <ul>
                                    <li><strong>Specific implementation:</strong> Ford-Fulkerson with BFS for finding augmenting paths</li>
                                    <li><strong>Time Complexity:</strong> O(VE¬≤) - polynomial!</li>
                                    <li><strong>Why BFS?:</strong> Finds shortest augmenting path (fewest edges), guarantees termination</li>
                                </ul>
                            </div>
                        </div>

                        <div class="subtopic">
                            <h3>Maximum Bipartite Matching</h3>
                            <div class="key-concepts">
                                <h4>Key Concepts:</h4>
                                <ul>
                                    <li><strong>Bipartite Graph:</strong> Vertices split into two sets, edges only between sets</li>
                                    <li><strong>Matching:</strong> Set of edges with no shared vertices</li>
                                    <li><strong>Maximum Matching:</strong> Matching with maximum number of edges</li>
                                    <li><strong>Reduction to Max Flow:</strong>
                                        <ul>
                                            <li>Add source s connected to all left vertices (capacity 1)</li>
                                            <li>Add sink t connected from all right vertices (capacity 1)</li>
                                            <li>All bipartite edges have capacity 1</li>
                                            <li>Max flow = Maximum matching size</li>
                                        </ul>
                                    </li>
                                </ul>
                            </div>
                            <div class="video-recommendations">
                                <h4>Video Recommendations:</h4>
                                <a href="https://www.youtube.com/watch?v=GhjwOiJ4SqU" target="_blank" class="video-link">üé• William Fiset - Bipartite Graph Matching (12 min)</a>
                            </div>
                            <div class="practice-tip">
                                <h4>Example Application:</h4>
                                <p>Job assignment: n workers, m jobs, edges show which workers can do which jobs. Max matching = maximum number of jobs that can be assigned.</p>
                            </div>
                        </div>

                        <div class="quick-reference">
                            <h3>Max Flow Quick Reference</h3>
                            <table class="complexity-table">
                                <thead>
                                    <tr>
                                        <th>Concept</th>
                                        <th>Definition</th>
                                        <th>Complexity</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr>
                                        <td>Ford-Fulkerson</td>
                                        <td>Method using augmenting paths</td>
                                        <td>O(E¬∑|f*|)</td>
                                    </tr>
                                    <tr>
                                        <td>Edmonds-Karp</td>
                                        <td>Ford-Fulkerson with BFS</td>
                                        <td>O(VE¬≤)</td>
                                    </tr>
                                    <tr>
                                        <td>Max-Flow Min-Cut</td>
                                        <td>Max flow value = Min cut capacity</td>
                                        <td>-</td>
                                    </tr>
                                    <tr>
                                        <td>Bipartite Matching</td>
                                        <td>Reduce to max flow problem</td>
                                        <td>O(VE¬≤)</td>
                                    </tr>
                                </tbody>
                            </table>
                        </div>

                        <ul class="checklist">
                            <li><input type="checkbox" onchange="updateProgress()"> Understand flow network properties</li>
                            <li><input type="checkbox" onchange="updateProgress()"> Know what residual graph represents</li>
                            <li><input type="checkbox" onchange="updateProgress()"> Can trace Ford-Fulkerson algorithm</li>
                            <li><input type="checkbox" onchange="updateProgress()"> Understand Max-Flow Min-Cut theorem</li>
                            <li><input type="checkbox" onchange="updateProgress()"> Know how to reduce bipartite matching to max flow</li>
                            <li><input type="checkbox" onchange="updateProgress()"> Review problem set ps8</li>
                        </ul>
                    </div>
                </div>

                <!-- FINAL REVIEW SECTION -->
                <div class="topic-section" id="review">
                    <h2 onclick="toggleSection('review')">
                        <span class="toggle-icon">‚ñº</span>
                        6. Practice Problems Review
                    </h2>
                    <div class="topic-content">
                        <div class="practice-tip">
                            <h4>Focus on Your Problem Sets!</h4>
                            <p>Your problem sets (ps1-sol.pdf through ps8-sol.pdf) are in the Assignment_answer_sols folder. These are gold!</p>
                            <ol>
                                <li><strong>Rework Problems:</strong> Try solving without looking at solutions first</li>
                                <li><strong>Understand Solutions:</strong> Don't just read - understand WHY each step works</li>
                                <li><strong>Identify Patterns:</strong> Notice which techniques apply to which problem types</li>
                                <li><strong>Tricky Problems:</strong> Problems you got wrong initially are likely to appear in similar form</li>
                            </ol>
                        </div>

                        <div class="subtopic">
                            <h3>Problem Set Focus Areas</h3>
                            <ul>
                                <li><strong>ps1-ps3:</strong> Likely focus on graphs, BFS/DFS, topological sort, SCCs</li>
                                <li><strong>ps3-ps4:</strong> Dijkstra's, divide & conquer, recurrence relations</li>
                                <li><strong>ps4-ps5:</strong> Master theorem, greedy algorithms, activity selection</li>
                                <li><strong>ps5-ps6:</strong> MST (Kruskal & Prim), Huffman coding</li>
                                <li><strong>ps6-ps7:</strong> Dynamic programming problems</li>
                                <li><strong>ps8:</strong> Maximum flow, bipartite matching</li>
                            </ul>
                        </div>

                        <div class="warning-box">
                            <h4>Common Exam Mistakes to Avoid:</h4>
                            <ul>
                                <li>Confusing BFS and DFS applications</li>
                                <li>Applying Master Theorem when it doesn't apply</li>
                                <li>Using Dijkstra's with negative weights</li>
                                <li>Forgetting to check if graph is a DAG for topological sort</li>
                                <li>Mixing up Kruskal's and Prim's approaches</li>
                                <li>Not understanding WHEN to use greedy vs DP</li>
                            </ul>
                        </div>
                    </div>
                </div>

                <!-- FINAL MORNING REVIEW -->
                <div class="topic-section" id="final-review">
                    <h2 onclick="toggleSection('final-review')">
                        <span class="toggle-icon">‚ñº</span>
                        7. Final Morning Review
                    </h2>
                    <div class="topic-content">
                        <div class="study-tips">
                            <h3>Last Hour Before Exam:</h3>
                            <ul>
                                <li>Review all complexity tables below</li>
                                <li>Skim through algorithm pseudocode</li>
                                <li>Quick mental walk-through of each algorithm</li>
                                <li>Review any problem set problems you struggled with</li>
                                <li>Stay calm - you've got this!</li>
                            </ul>
                        </div>

                        <div class="quick-reference">
                            <h3>Master Complexity Reference</h3>
                            <table class="complexity-table">
                                <thead>
                                    <tr>
                                        <th>Algorithm/Structure</th>
                                        <th>Time Complexity</th>
                                        <th>Space</th>
                                        <th>Notes</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr>
                                        <td>BFS</td>
                                        <td>O(V + E)</td>
                                        <td>O(V)</td>
                                        <td>Queue, level-by-level</td>
                                    </tr>
                                    <tr>
                                        <td>DFS</td>
                                        <td>O(V + E)</td>
                                        <td>O(V)</td>
                                        <td>Stack/recursion, depth-first</td>
                                    </tr>
                                    <tr>
                                        <td>Topological Sort</td>
                                        <td>O(V + E)</td>
                                        <td>O(V)</td>
                                        <td>DFS-based, DAGs only</td>
                                    </tr>
                                    <tr>
                                        <td>SCC (Kosaraju)</td>
                                        <td>O(V + E)</td>
                                        <td>O(V)</td>
                                        <td>Two DFS passes</td>
                                    </tr>
                                    <tr>
                                        <td>Dijkstra's</td>
                                        <td>O((V+E) log V)</td>
                                        <td>O(V)</td>
                                        <td>Non-negative weights only</td>
                                    </tr>
                                    <tr>
                                        <td>Strassen's</td>
                                        <td>O(n^2.81)</td>
                                        <td>O(n¬≤)</td>
                                        <td>7 multiplications</td>
                                    </tr>
                                    <tr>
                                        <td>Activity Selection</td>
                                        <td>O(n log n)</td>
                                        <td>O(1)</td>
                                        <td>Sort by finish time</td>
                                    </tr>
                                    <tr>
                                        <td>Huffman Coding</td>
                                        <td>O(n log n)</td>
                                        <td>O(n)</td>
                                        <td>Min-heap based</td>
                                    </tr>
                                    <tr>
                                        <td>Kruskal's MST</td>
                                        <td>O(E log E)</td>
                                        <td>O(V)</td>
                                        <td>Sort edges, Union-Find</td>
                                    </tr>
                                    <tr>
                                        <td>Prim's MST</td>
                                        <td>O((V+E) log V)</td>
                                        <td>O(V)</td>
                                        <td>Grow from vertex, min-heap</td>
                                    </tr>
                                    <tr>
                                        <td>Matrix Chain Mult.</td>
                                        <td>O(n¬≥)</td>
                                        <td>O(n¬≤)</td>
                                        <td>DP, optimal parenthesization</td>
                                    </tr>
                                    <tr>
                                        <td>LCS</td>
                                        <td>O(mn)</td>
                                        <td>O(mn)</td>
                                        <td>DP, 2D table</td>
                                    </tr>
                                    <tr>
                                        <td>Ford-Fulkerson</td>
                                        <td>O(E¬∑|f*|)</td>
                                        <td>O(V+E)</td>
                                        <td>Augmenting paths</td>
                                    </tr>
                                    <tr>
                                        <td>Edmonds-Karp</td>
                                        <td>O(VE¬≤)</td>
                                        <td>O(V+E)</td>
                                        <td>BFS for paths</td>
                                    </tr>
                                </tbody>
                            </table>
                        </div>

                        <div class="quick-reference">
                            <h3>Key Theorems & Properties</h3>
                            <ul>
                                <li><strong>Master Theorem:</strong> T(n) = aT(n/b) + f(n) - compare f(n) with n^(log_b a)</li>
                                <li><strong>Greedy Choice Property:</strong> Optimal solution contains greedy choice</li>
                                <li><strong>Optimal Substructure:</strong> Required for both DP and greedy</li>
                                <li><strong>Max-Flow Min-Cut:</strong> Maximum flow = Minimum cut capacity</li>
                                <li><strong>MST Properties:</strong> V-1 edges, unique if weights distinct, light edge crossing cut is safe</li>
                                <li><strong>Cut Property:</strong> For any cut, minimum weight edge crossing it is in some MST</li>
                            </ul>
                        </div>

                        <div class="resources-section">
                            <h3>If You Have Extra Time:</h3>
                            <a href="https://www.youtube.com/watch?v=JPyuH4qXLZ0" target="_blank" class="video-link">üé• Abdul Bari's Algorithm Playlist (Full Course Review)</a>
                            <a href="https://visualgo.net/" target="_blank" class="video-link">üîó VisuAlgo - Algorithm Visualizations</a>
                            <a href="https://www.bigocheatsheet.com/" target="_blank" class="video-link">üîó Big-O Cheat Sheet</a>
                        </div>
                    </div>
                </div>
            </main>
        </div>
    </div>

    <script>
        // Toggle section collapse
        function toggleSection(sectionId) {
            const section = document.getElementById(sectionId);
            const content = section.querySelector('.topic-content');
            const icon = section.querySelector('.toggle-icon');

            content.classList.toggle('collapsed');
            icon.classList.toggle('collapsed');
        }

        // Update progress based on checkboxes
        function updateProgress() {
            const allCheckboxes = document.querySelectorAll('.checklist input[type="checkbox"]');
            const checkedBoxes = document.querySelectorAll('.checklist input[type="checkbox"]:checked');
            const progress = (checkedBoxes.length / allCheckboxes.length) * 100;

            const progressBar = document.getElementById('progressBar');
            progressBar.style.width = progress + '%';
            progressBar.textContent = Math.round(progress) + '%';

            // Update checkbox parent styling
            allCheckboxes.forEach(checkbox => {
                const li = checkbox.closest('li');
                if (checkbox.checked) {
                    li.classList.add('checked');
                } else {
                    li.classList.remove('checked');
                }
            });

            // Save progress to localStorage
            saveProgress();
        }

        // Save progress to localStorage
        function saveProgress() {
            const checkboxes = document.querySelectorAll('.checklist input[type="checkbox"]');
            const progress = {};
            checkboxes.forEach((checkbox, index) => {
                progress[index] = checkbox.checked;
            });
            localStorage.setItem('studyProgress', JSON.stringify(progress));
        }

        // Load progress from localStorage
        function loadProgress() {
            const saved = localStorage.getItem('studyProgress');
            if (saved) {
                const progress = JSON.parse(saved);
                const checkboxes = document.querySelectorAll('.checklist input[type="checkbox"]');
                checkboxes.forEach((checkbox, index) => {
                    if (progress[index]) {
                        checkbox.checked = true;
                    }
                });
                updateProgress();
            }
        }

        // Reset progress
        function resetProgress() {
            if (confirm('Are you sure you want to reset all progress?')) {
                localStorage.removeItem('studyProgress');
                const checkboxes = document.querySelectorAll('.checklist input[type="checkbox"]');
                checkboxes.forEach(checkbox => {
                    checkbox.checked = false;
                });
                updateProgress();
            }
        }

        // Quiz functionality
        function checkAnswer(element, isCorrect, explanationId) {
            // Remove previous selections in this question
            const options = element.parentElement.querySelectorAll('.quiz-option');
            options.forEach(opt => {
                opt.classList.remove('selected', 'correct', 'incorrect');
            });

            // Mark the selected option
            element.classList.add('selected');
            if (isCorrect) {
                element.classList.add('correct');
                // Show explanation
                const explanation = document.getElementById(explanationId);
                if (explanation) {
                    explanation.classList.add('show');
                }
            } else {
                element.classList.add('incorrect');
            }
        }

        // Toggle answer visibility
        function toggleAnswer(answerId) {
            const answer = document.getElementById(answerId);
            if (answer) {
                answer.classList.toggle('revealed');
            }
        }

        // Countdown timer
        function updateCountdown() {
            // You can set your exam date/time here
            // For demo, showing a simple message
            const countdownElement = document.getElementById('countdown');
            countdownElement.textContent = 'Focus on understanding, not memorizing. You\'ve got this!';
        }

        // Initialize
        document.addEventListener('DOMContentLoaded', function() {
            loadProgress();
            updateCountdown();

            // Add change listeners to all checkboxes
            const checkboxes = document.querySelectorAll('.checklist input[type="checkbox"]');
            checkboxes.forEach(checkbox => {
                checkbox.addEventListener('change', updateProgress);
            });
        });

        // Keyboard shortcuts
        document.addEventListener('keydown', function(e) {
            // Press 'r' to reset (when not in input field)
            if (e.key === 'r' && e.target.tagName !== 'INPUT') {
                resetProgress();
            }
        });
    </script>
</body>
</html>